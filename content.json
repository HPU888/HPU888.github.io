{"pages":[{"title":"关于我！","text":"大家好，我是一名前端工程师，每天会根据时间更新一下自己的博客，内容是自己所学亦或是从别处理解之个人见解，前端道路漫长，有趣之中也会有很多烦躁，所以也会更新一下夜读美文，或者经典语句，夜深人静之时，解解闷儿。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"link","text":"","link":"/link/index.html"}],"posts":[{"title":"JS面试中常见的算法题","text":"js除了基础知识以外，算法也是挺重要的。因此特意整理了一些常见的算法题，希望大家有帮助。 1、验证一个数是否是素数 如果这个数是 2 或 3，一定是素数； 如果是偶数，一定不是素数； 如果这个数不能被3~它的平方根中的任一数整除，m必定是素数。而且除数可以每次递增（排除偶数）。 function isPrime(num){ if (num === 2 || num === 3) { return true; }; if (num % 2 === 0) { return false; }; let divisor = 3,limit = Math.sqrt(num); while(limit &gt;= divisor){ if (num % divisor === 0) { return false; } else { divisor += 2; } } return true;}console.log(isPrime(30)); // false 2、斐波那契最简单的做法：递归。 function fibonacci(n){ if (n &lt;= 0) { return 0; } if (n == 0) { return 1; } return fibonacci(n-1) + fibonacci(n-2);} 但是递归会有严重的效率问题。比如想要求得f(10)，首先需要求f(9)和f(8)。同样，想求f(9)，首先需要f(8)和f(7)…这样就有很多重复值，计算量也很大。 改进：从下往上计算，首先根据f(0)和f(1)计算出f(2)，再根据f(1)和f(2)计算出f(3)……以此类推就可以计算出第n项。时间复杂度O(n)。 function fibonacci(n){ let ori = [0,1]; if (n &lt; 2) { return ori[n]; }; let fiboOne = 1,fiboTwo = 0,fiboSum = 0; for (let i = 2; i &lt;= n; i++) { fiboSum = fiboOne + fiboTwo; fiboTwo = fiboOne; fiboOne = fiboSum; } return fiboSum;}console.log(fibonacci(5)); 3、求最大公约数除数 在a和b的范围内，如果同时a和b处以除数的余等于0，就将此时的除数赋值给res；除数自增，不断循环上面的计算，更新res。 function greatestCommonDivisor(a, b){ let divisor = 2,res = 1; if (a &lt; 2 || b &lt; 2) { return 1; }; while(a &gt;= divisor &amp;&amp; b &gt;= divisor){ if (a%divisor === 0 &amp;&amp; b%divisor === 0) { res = divisor; } divisor++; } return res;};console.log(greatestCommonDivisor(8, 4)); // 4console.log(greatestCommonDivisor(69, 169)); // 1 解法2 function greatestCommonDivisor(a,b){ if (b === 0) { return a; } else { return greatestCommonDivisor(b,a%b); }}; 4、数组去重对原数组进行遍历获取arr[i]的值 j；对应到辅助数组 exits 的位置 j 的值，如果没有，则证明arr[i] 的值没有重复，此时将 值j 存入res数组，并将辅助数组 j 位置的值置为true。最后返回res数组。 function removeDuplicate(arr){ if (arr === null || arr.length &lt; 2) { return arr; }; let res = [],exits = []; for(let i = 0; i &lt; arr.length; i++){ let j = arr[i]; while( !exits[j] ){ res.push(arr[i]); exits[j] = true; } } return res;}console.log(removeDuplicate([1,3,3,3,1,5,6,7,8,1])) // [1,3,5,6,7,8] 5、删除重复的字符这一题的解法和上一题类似。 function removeDuplicateChar(str){ if (!str || str.length &lt; 2 || typeof str != \"string\") { return; }; let charArr = [],res = []; for(let i = 0; i &lt; str.length; i++){ let c = str[i]; if(charArr[c]){ charArr[c]++; } else{ charArr[c] = 1; } } for(let j in charArr){ if (charArr[j] === 1) { res.push(j); } } return res.join(\"\");}console.log(removeDuplicateChar(\"Learn more javascript dude\")); 6、排序两个已经排好序的数组如果 b数组已经遍历完，a数组还有值 或 a[i] 的值 小于等于 b[i] 的值，则将 a[i] 添加进数组res，并 i++；如果不是上面的情况，则将 b[i] 添加进数组res，并 i++； function mergeSortedArr(a,b){ if (!a || !b) { return; }; let aEle = a[0],bEle = b[0],i = 1,j = 1,res = []; while(aEle || bEle){ if ((aEle &amp;&amp; !bEle) || aEle &lt;= bEle) { res.push(aEle); aEle = a[i++]; } else{ res.push(bEle); bEle = b[j++]; } } return res;}console.log(mergeSortedArr([2,5,6,9], [1,2,3,29])) // [1,2,2,3,5,6,9,29] 7、字符串反向function reverse(str){ let resStr = \"\"; for(let i = str.length-1; i &gt;= 0; i--){ resStr += str[i]; } return resStr;}console.log(reverse(\"ABCDEFG\"));function reverse2(str){ if (!str || str.length &lt; 2 || typeof str != \"string\") { return str; }; let res = []; for(let i = str.length-1; i &gt;= 0; i--){ res.push(str[i]); } return res.join(\"\");}console.log(reverse2(\"Hello\")); 将函数添加到String.prototype String.prototype.reverse3 = function(){ if (!this || this.length &lt; 2) { return; }; let res = []; for(let i = this.length-1; i &gt;= 0; i--){ res.push(this[i]); } return res.join(\"\");}console.log(\"abcdefg\".reverse3()); 8、字符串原位反转例如：将“I am the good boy”反转变为 “I ma eht doog yob”。 提示：使用数组和字符串方法。 function reverseInPlace(str){ return str.split(' ').reverse().join(' ').split('').reverse().join('');}console.log(reverseInPlace('I am the good boy')); 9、判断是否是回文function isPalindrome(str){ if (!str || str.length &lt; 2) { return; } for(let i = 0; i &lt; str.length/2; i++){ if (str[i] !== str[str.length-1-i]) { return false; } } return true;}console.log(isPalindrome(\"madama\")) 10、判断数组中是否有两数之和eg：在一个未排序的数组中找出是否有任意两数之和等于给定的数。 给出一个数组[6,4,3,2,1,7]和一个数9，判断数组里是否有任意两数之和为9。 eg：在一个未排序的数组中找出是否有任意两数之和等于给定的数。 给出一个数组[6,4,3,2,1,7]和一个数9，判断数组里是否有任意两数之和为9。 function sumFind(arr,num){ if (!arr || arr.length &lt; 2) { return; }; let differ = {}; for(let i = 0; i &lt; arr.length; i++){ let subStract = num - arr[i]; if (differ[subStract]) { return true; } else{ differ[arr[i]] = true; } } return false;}console.log(sumFind([6,4,3,2,1,7], 9)); // true 11、连字符转成驼峰如：get-element-by-id 转为 getElementById let str = 'get-element-by-id';let arr = str.split('-');for(let i=1; i&lt;arr.length; i++){ arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1);}console.log(arr.join('')); // getElementById 12、加油站问题-贪心算法一辆汽车加满油后可行驶n公里。旅途中有若干个加油站。设计一个有效算法，指出应在哪些加油站停靠加油，使沿途加油次数最少。对于给定的n(n &lt;= 5000)和k(k &lt;= 1000)个加油站位置，编程计算最少加油次数。并证明算法能产生一个最优解。 要求： 输入：第一行有2个正整数n和k，表示汽车加满油后可行驶n公里，且旅途中有k个加油站。接下来的1 行中，有k+1 个整数，表示第k个加油站与第k-1 个加油站之间的距离。第0 个加油站表示出发地，汽车已加满油。第k+1 个加油站表示目的地。 输出：输出编程计算出的最少加油次数。如果无法到达目的地，则输出”NoSolution”。 function greedy(n, k, arr){ // n:加满可以行驶的公里数; k:加油站数量; arr:每个加油站之间的距离数组 if (n == 0 || k == 0 || arr.length == 0 || arr[0] &gt; n) { return \"No Solution!\"; // arr[0] &gt; n ：如果第一个加油站距离太远，也无法到达 }; let res = 0, distance = 0; // res：加油次数；distance：已行驶距离 for(let i = 0; i &lt;= k; i++){ distance += arr[i]; if (distance &gt; n) { // 已行驶距离 &gt; 加满可以行驶的公里数 if(arr[i] &gt; n){ // 如果目前加油站和前一个加油站的距离 &gt; 加满可以行驶的公里数，则无法到达 return \"No Solution!\"; }; // 可以在上一个加油站加油，行驶到目前的加油站i： distance = arr[i]; res++; // 加油次数+1 } } return res;}let arr = [1,2,3,4,5,1,6,6];console.log(greedy(7,7,arr)) // 4 13、用正则实现trim() 清除字符串两端空格String.prototype.trim1 = function(){ // return this.replace(/\\s*/g,\"\"); // 清除所有空格 return this.replace(/(^\\s*)|(\\s*$)/g,\"\"); // 清除字符串前后的空格};console.log(\" hello word \".trim1()) // \"hello word\" 14、将数字12345678转化成RMB形式：12,345,678思路：将字符串切割成数组再反转，遍历数组，加入辅助数组，当数组长度为3的倍数，再向辅助数组加入 “,”。 function RMB(str){ let arr = str.split(\"\").reverse(); let res = []; for(let i = 0; i &lt; arr.length; i++){ res.push(arr[i]); if ((i + 1) % 3 === 0) { res.push(\",\"); } } return res.reverse().join(\"\");}console.log(RMB(\"12345678\")) 15、删除相邻相同的字符串function delSrt(str){ let res = [], nowStr; for(let i = 0; i &lt; str.length; i ++){ if (str.charAt(i) != nowStr) { res.push(str.charAt(i)); nowStr = str.charAt(i); } } return res.join(\"\");}console.log(delSrt(\"aabcc11\"))","link":"/JS面试中常见的算法题/"},{"title":"JavaScript手写代码无敌秘籍","text":"中高级前端面试之手写代码 实现一个new操作符 实现一个JSON.stringify 实现一个JSON.parse 实现一个call或 apply 实现一个Function.bind 实现一个继承 实现一个JS函数柯里化 手写一个Promise(中高级必考) 手写防抖(Debouncing)和节流(Throttling) 手写一个JS深拷贝 实现一个instanceOf 1. 实现一个 new 操作符 new 操作符做了这些事： 它创建了一个全新的对象。 它会被执行 [[Prototype]]（也就是 __proto__）链接。 它使 this 指向新创建的对象。 通过 new 创建的每个对象将最终被 [[Prototype]] 链接到这个函数的 prototype 对象上。 如果函数没有返回对象类型 Object (包含 Functoin, Array, Date, RegExg, Error )，那么 new 表达式中的函数调用将返回该对象引用。 function New(func) { var res = {}; if (func.prototype !== null) { res.__proto__ = func.prototype; } var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === \"object\" || typeof ret === \"function\") &amp;&amp; ret !== null) { return ret; } return res;}var obj = New(A, 1, 2);// equals tovar obj = new A(1, 2); 2. 实现一个 JSON.stringify JSON.stringify(value[, replacer [, space]]) Boolean | Number| String 类型会自动转换成对应的原始值。 undefined、任意函数以及 symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。 不可枚举的属性会被忽略 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。 function jsonStringify(obj) { let type = typeof obj; if (type !== \"object\") { if (/string|undefined|function/.test(type)) { obj = '\"' + obj + '\"'; } return String(obj); } else { let json = [] let arr = Array.isArray(obj) for (let k in obj) { let v = obj[k]; let type = typeof v; if (/string|undefined|function/.test(type)) { v = '\"' + v + '\"'; } else if (type === \"object\") { v = jsonStringify(v); } json.push((arr ? \"\" : '\"' + k + '\":') + String(v)); } return (arr ? \"[\" : \"{\") + String(json) + (arr ? \"]\" : \"}\") }}jsonStringify({x : 5}) // \"{\"x\":5}\"jsonStringify([1, \"false\", false]) // \"[1,\"false\",false]\"jsonStringify({b: undefined}) // \"{\"b\":\"undefined\"}\" 3. 实现一个 JSON.parse JSON.parse(text[, reviver]) 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。 3.1 第一种：直接调用 evalfunction jsonParse(opt) { return eval('(' + opt + ')');}jsonParse(jsonStringify({x : 5}))// Object { x: 5}jsonParse(jsonStringify([1, \"false\", false]))// [1, \"false\", falsr]jsonParse(jsonStringify({b: undefined}))// Object { b: \"undefined\"} 避免在不必要的情况下使用 eval，eval() 是一个危险的函数， 他执行的代码拥有着执行者的权利。如果你用 eval()运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。 它会执行JS代码，有XSS漏洞。 如果你只想记这个方法，就得对参数json做校验。var rx_one = /^[\\],:{}\\s]*$/;var rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;var rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;if ( rx_one.test( json .replace(rx_two, \"@\") .replace(rx_three, \"]\") .replace(rx_four, \"\") )) { var obj = eval(\"(\" +json + \")\");} 3.2 第二种：Function核心：Function 与 eval 有相同的字符串参数特性。 var func = new Function(arg1, arg2, ..., functionBody); 在转换JSON的实际应用中，只需要这么做。 var jsonStr = '{ \"age\": 20, \"name\": \"jack\" }'var json = (new Function('return ' + jsonStr))(); eval 与 Function 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。 4. 实现一个 call 或 apply call 语法： fun.call(thisArg, arg1, arg2, …)，调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 apply 语法： func.apply(thisArg, [argsArray])，调用一个函数，以及作为一个数组（或类似数组对象）提供的参数。 4.1 Function.call 按套路实现call核心： 将函数设为对象的属性 执行&amp;删除这个函数 指定this到函数并传入给定参数执行函数 如果不传入参数，默认指向为 window 4.1.1 简单版var foo = { value: 1, bar: function() { console.log(this.value) }}foo.bar() // 1 4.1.2 完善版Function.prototype.call2 = function(content = window) { content.fn = this; let args = [...arguments].slice(1); let result = content.fn(...args); delete content.fn; return result;}let foo = { value: 1}function bar(name, age) { console.log(name) console.log(age) console.log(this.value);}bar.call2(foo, 'black', '18') // black 18 1 4.2 Function.apply 的模拟实现apply() 的实现和 call() 类似，只是参数形式不同。Function.prototype.apply2 = function(context = window) { context.fn = this let result; // 判断是否有第二个参数 if(arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result} 5. 实现一个 Function.bind() bind() 方法: 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 此外，bind 实现需要考虑实例化后对原型链的影响。 Function.prototype.bind2 = function(content) { if(typeof this != \"function\") { throw Error(\"not a function\") } // 若没问参数类型则从这开始写 let fn = this; let args = [...arguments].slice(1); let resFn = function() { return fn.apply(this instanceof resFn ? this : content,args.concat(...arguments) ) } function tmp() {} tmp.prototype = this.prototype; resFn.prototype = new tmp(); return resFn;} 6. 实现一个继承 寄生组合式继承 一般只建议写这种，因为其它方式的继承会在一次实例中调用两次父类的构造函数或有其它缺点。 核心实现是：用一个 *F 空的构造函数去取代执行了 Parent* 这个构造函数。 function Parent(name) { this.name = name;}Parent.prototype.sayName = function() { console.log('parent name:', this.name);}function Child(name, parentName) { Parent.call(this, parentName); this.name = name; }function create(proto) { function F(){} F.prototype = proto; return new F();}Child.prototype = create(Parent.prototype);Child.prototype.sayName = function() { console.log('child name:', this.name);}Child.prototype.constructor = Child;var parent = new Parent('father');parent.sayName(); // parent name: fathervar child = new Child('son', 'father'); 7. 实现一个JS函数柯里化 什么是柯里化？ 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。 函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。 7.1 通用版function curry(fn, args) { var length = fn.length; var args = args || []; return function(){ newArgs = args.concat(Array.prototype.slice.call(arguments)); if (newArgs.length &lt; length) { return curry.call(this,fn,newArgs); }else{ return fn.apply(this,newArgs); } }}function multiFn(a, b, c) { return a * b * c;}var multi = curry(multiFn);multi(2)(3)(4);multi(2,3,4);multi(2)(3,4);multi(2,3)(4); 7.2 ES6写法const curry = (fn, arr = []) =&gt; (...args) =&gt; ( arg =&gt; arg.length === fn.length ? fn(...arg) : curry(fn, arg))([...arr, ...args])let curryTest=curry((a,b,c,d)=&gt;a+b+c+d)curryTest(1,2,3)(4) //返回10curryTest(1,2)(4)(3) //返回10curryTest(1,2)(3,4) //返回10 8. 手写一个 Promise (中高级必考) 我们来过一遍 Promise/A+ 规范： 三种状态 pending| fulfilled(resolved) | rejected 当处于 pending 状态的时候，可以转移到 fulfilled(resolved)或者 rejected状态 当处于 fulfilled(resolved) 状态或者 rejected 状态的时候，就不可变。 必须有一个 then 异步执行方法，then 接受两个参数且必须返回一个 promise. // onFulfilled 用来接收promise成功的值// onRejected 用来接收promise失败的原因var promise1=promise.then(onFulfilled, onRejected); 8.1 Promise 的流程图分析 来回顾下 Promise 用法： var promise = new Promise((resolve,reject) =&gt; { if (操作成功) { resolve(value) } else { reject(error) }})promise.then(function (value) { // success},function (value) { // failure}) 8.2 面试版function myPromise(constructor){ let self=this; self.status=\"pending\" //定义状态改变前的初始状态 self.value=undefined;//定义状态为resolved的时候的状态 self.reason=undefined;//定义状态为rejected的时候的状态 function resolve(value){ //两个===\"pending\"，保证了状态的改变是不可逆的 if(self.status===\"pending\"){ self.value=value; self.status=\"resolved\"; } } function reject(reason){ //两个===\"pending\"，保证了状态的改变是不可逆的 if(self.status===\"pending\"){ self.reason=reason; self.status=\"rejected\"; } } //捕获构造异常 try{ constructor(resolve,reject); }catch(e){ reject(e); }} 同时，需要在 myPromise 的原型上定义链式调用的 then 方法： myPromise.prototype.then=function(onFullfilled,onRejected){ let self=this; switch(self.status){ case \"resolved\": onFullfilled(self.value); break; case \"rejected\": onRejected(self.reason); break; default: }} 测试一下： var p=new myPromise(function(resolve,reject){resolve(1)});p.then(function(x){console.log(x)})//输出1 8.3 大厂专供版直接贴代码 const PENDING = \"pending\";const FULFILLED = \"fulfilled\";const REJECTED = \"rejected\";function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if(value instanceof Promise) { return value.then(resolve, reject); } // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() =&gt; { // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) { // 只能由pending状态 =&gt; fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() =&gt; { // 调用reject 回调对应onRejected函数 if (that.status === PENDING) { // 只能由pending状态 =&gt; rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) =&gt; { // throw new Error('error in excutor') // }) try { excutor(resolve, reject); } catch (e) { reject(e); }}Promise.prototype.then = function(onFulfilled, onRejected) { const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === \"function\" ? onRejected : reason =&gt; { throw reason; }; if (that.status === FULFILLED) { // 成功态 return newPromise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { try{ let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 } catch(e) { reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); } }); }) } if (that.status === REJECTED) { // 失败态 return newPromise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { try { let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } if (that.status === PENDING) { // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) =&gt; { that.onFulfilledCallbacks.push((value) =&gt; { try { let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); that.onRejectedCallbacks.push((reason) =&gt; { try { let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); }}; 9. 手写防抖(Debouncing)和节流(Throttling) scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），有两种常用的解决方法，防抖和节流。 9.1 防抖( Debouncing )实现典型例子：限制 鼠标连击 触发。 一个比较好的解释是： 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。 // 防抖动函数function debounce(fn,wait=50,immediate) { let timer; return function() { if(immediate) { fn.apply(this,arguments) } if(timer) clearTimeout(timer) timer = setTimeout(()=&gt; { fn.apply(this,arguments) },wait) }} 结合实例：滚动防抖 // 简单的防抖动函数// 实际想绑定在 scroll 事件上的 handlerfunction realFunc(){ console.log(\"Success\");}// 采用了防抖动window.addEventListener('scroll',debounce(realFunc,500));// 没采用防抖动window.addEventListener('scroll',realFunc); 9.2 节流( Throttling )实现 可以理解为事件在一个管道中传输，加上这个节流阀以后，事件的流速就会减慢。实际上这个函数的作用就是如此，它可以将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次. 简单的节流函数: function throttle(fn, wait) { let prev = new Date(); return function() { const args = arguments; const now = new Date(); if (now - prev &gt; wait) { fn.apply(this, args); prev = new Date(); } }} 9.3 结合实践通过第三个参数来切换模式。 const throttle = function (fn, delay, isDebounce) { let timer; let lastCall = 0; return function (...args) { if (isDebounce) { if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; { fn(...args); }, delay); } else { const now = new Date().getTime(); if (now - lastCall &lt; delay) return; lastCall = now; fn(...args); } }} 10. 手写一个 JS 深拷贝 10.1 最简版var newObj = JSON.parse( JSON.stringify( someObj )); 10.2 面试版function deepCopy(obj){ //判断是否是简单数据类型， if(typeof obj == \"object\"){ //复杂数据类型 var result = obj.constructor == Array ? [] : {}; for(let i in obj){ result[i] = typeof obj[i] == \"object\" ? deepCopy(obj[i]) : obj[i]; } }else { //简单数据类型 直接 == 赋值 var result = obj; } return result;} 11. 实现一个 instanceOf function instanceOf(left,right) { let proto = left.__proto__; let prototype = right.prototype while(true) { if(proto === null) return false if(proto === prototype) return true proto = proto.__proto__; }}","link":"/JavaScript手写代码无敌秘籍/"},{"title":"心越简单，人越幸福","text":"幸福有时真的很简单！曾经总以为，要想获得幸福，需要许多外在物质的支撑。 可随着年龄的增长，你逐渐会发现，幸福更多时刻，只是一种内心的感受，与金钱名利无关。 当你拖着疲惫的身躯，加班回到家，发现城市的万千灯火里，能有一盏灯为你亮时。 当你生病住院时，能有个人陪在你身旁，为你熬药煮粥，对你不离不弃时。 当你感到快乐时，你可以找到一个人，分享你的喜悦。当你难过时，也有一个人，可以给你一个肩膀做依靠时。 幸福并不遥远，它近在咫尺。幸福也并不陌生，它就藏在我们熟悉的生活中，关键需要你用心地去发现和感知。 人人都有拥有幸福的权利，但如果你要求得太多，苛责得太多，抱怨得太多，就不容易找到它。 其实，你若能从琐碎的日常中，从柴米油盐的平凡日子里，提炼出美好的能力，也可以将日子开出绚烂的花儿。 你是否有这样的感觉，有时会感到很孤独。因为聊得来的人越来越少，可以交心的人也越来越少。 无论你做任何决定，有什么选择，周围的人，仿佛都不理解你，甚至他们还总是质疑你。 有时，你还会为此，有深深的挫败感。 但你总要知道，人这辈子，无法做到让所有人都满意，也不必让所有人都懂你，如果强求，只会让自己过得越来越疲惫。 一个前同事给我打来电话，诉说她这段时间，在工作中遇到的烦心事。 她不无委屈地说，为什么我做了一件好事，但员工都不理解我，他们只看得见眼前的利益，却看不见长远的打算。 我安慰她说，只要你心是善的，你的决定，也经得起时间的考验，那么无论他们是否明白，你都可以做到问心无愧。 她听后说到，现在我的心情释然了很多，至少还有你理解我。 当我们在做决定时，总被旁人的眼光和评价所左右，甚至我们也总想得到更多人的支持和认可。 后来才明白，在这个世上，懂你的人，不必你解释。不懂你的人，解释也无用。 人生有时，并不需要有那么多人懂你，你自己懂你自己，以及有那么一两个知己好友懂你，就足矣。 一个读者跟我说，她有一次帮客户去找房子，跟着中介，在炎炎夏日的街头跑了一天，不仅又累又热，双脚还磨起了泡。 但她当时最大的感受，反而不是抱怨身体上吃的苦，而是突然感觉到自己平时真的太幸福了。 曾经她总对自己的工作不满意，比如任务重，压力大，考核严。那时，她总拿自己，跟那些高薪高职的人相比，于是越比心里就越不平衡。 可她现在才知道，原来在这个世界上，还有比她更辛苦，更忙碌，更劳碌的人，并没有她那么好的工作条件，可以不用日晒雨淋，可以有节庆双休，也拥有更多时间上的自由。 因为她总看到，别人有着比她更优越的条件，所以会心生嫉妒，但她却没有看到别人付出的比她多。 同时，她也并不知道，只要你尽自己所能，干好自己应该干的，哪怕是一件看起来微不足道的小事，也算是成功。 其实，大多数人的不快乐，往往来源于爱比较和不知足。 凡事你若争强好胜，只会让自己越来越痛苦。 但若你懂得，怀着一颗感恩的心，去珍惜你的工作，去善待你的生活，那么你就会多一分坦然和快乐。 虽然每个人对幸福的定义不一样，但幸福的感受，往往是相似的，想要获得幸福的心，也是相同的。 也许我们会因为各种条件，机遇和环境的不同，而过上截然不同的人生，但只要我们学会给心灵减负，学会控制欲望，学会不去盲目攀比，就会让自己活得更加轻松愉快。 其实，幸福有时真的很简单。 比如你拥有一份稳定的工作，虽然它需要你忙一点，累一点，辛苦一点，但它可以让你去实现自己的人生价值，也可以让你有底气和资本去挣钱养家。 比如你拥有一个和睦的家庭，虽然父母观念老一点，孩子调皮一点，另一半的脾气大一点，但家人闲坐，灯火可亲的感觉，是那么难能可贵。 比如你拥有几个可以互诉衷肠的朋友，虽然他们有时并不能给你及时的安慰和陪伴，又或者你们之间有些小矛盾，但能有哪怕一个交心的知己，也是人生一大幸事。 但如果你将幸福看得太复杂，你的内心太浑浊，你用恶意去揣测你所遇到的人和事，那么你就会感到十分压抑和痛苦。 其实当一个人，少一些世故，多一些单纯；少一些套路，多一些真诚；少一些浮躁，多一些宁静；就会活得更加澄明、坦率和自由。","link":"/夜读20191004/"},{"title":"一个人越过越好的6个迹象","text":"活成自己喜欢的样子！看到一句很有道理的话：一个人最好的状态莫过于，眼里写满了故事，脸上却不见风霜，不羡慕谁，不嘲笑谁，也不依赖谁。只是悄悄地努力，吞下委屈，喂大格局，活成自己喜欢的样子。 深以为然。 生活不需要太多事参与，故事不需要讲给太多人听。一个人安安静静努力，慢慢靠近自己想要的生活，就足矣。 生活越来越舒服，人生越过越成熟，自己越活越坦然的六个迹象，来看看，你中了几条？ 第一条，明白赚钱的重要性，但不把攒钱当作唯一目的。 亦舒说：记得积蓄，那样有朝一日失去任何人的欢心，都可以不愁衣食地伤春悲秋，缅怀过去。 的确，你不必特别有钱，但一定不能特别缺钱。钱不是万能的，但手里多一点钱，真的能叫自己少吃些苦。 赚钱和积蓄真的是很重要的事情。 不过，我希望你也要记得，别把攒钱当作唯一目的。 银行卡上的数字不应该成为你全部的安全感来源。 这世界，除了柴米油盐，还有远方的诗和田野。 不要总是低着头朝前走，偶尔停下脚步抬头看看满天的繁星。 想想自己当下最期待的生活是什么样的，不要忘记自己年少时的初心。 就像《流金岁月》中说的：无论做什么，记得为自己而做，那就毫无怨言。 人只活一辈子，不要太苛待自己，在能力范围之内给自己更好的，也是对生命的一种馈赠。 第二条，不害怕接近爱，也不盲目付出爱。 人活在世上，总免不了经历七情六欲，亲情、爱情、友情，点头之交，擦肩陌路…… 相遇和离别，每天都在上演。 以前总想着让认识的人都喜欢自己，想和更多的人成为朋友。 待人友善是修养，独来独往是性格。你不懂我，我不怪你，淡然远之，各自安好。 不害怕与人相处，也不惧于接受谁的好感和爱意。 但绝不会因为年龄或者一些本心之外的东西选择将就一段生活。 明白自己的感情很贵，不是谁都能给，如果不值得，如果没回应，那就算了。 余生很贵，取悦好自己，照顾好值得放在心上的人，不要将就，更别浪费。 第三条，比起无聊的消遣，更愿意独处和读书。 很多快速的东西往往都很短暂，偷走了你当下的时间，却并不能在你心里留下更深刻的印象。 偶尔小幅度的放纵可以让人感到愉悦和放松，但如果把堕落当成一种快乐，时间久了，只会让自己越来越难于开始自律。 没事早点睡，有空多读书，一个人的时候别浮躁，别焦虑；沉下心去磨一磨自己的脾气和性子，在书里见天地，见众生，更见自我。 要让自己成为一块有棱角但不锋芒外露，有骨气但外表温凉柔润的美玉。 你读过的书、走过的路和爱过的人，都会成为你人生路上的指路牌。那些也许你已经忘记了的书里的片段，其实都在指引你前行的方向。它们一定会在未来的某一个时刻，帮助你表现得更出色。 所以，要主动把自己从垃圾快乐中解救出来，独处和读书，往后余生，且行且记。 第四条，懂得自律才是自由的前提，并愿意为之付诸努力。 看过这样一句话：生活中的不如意总比如意多。 而对此的恪守、热情，恰恰也缘于自身的坚韧。时刻提醒自己，要自律，要保持内在的从容与安静。 无论在人生的哪个阶段，都不能放弃成长，没有人能限制你人生的高度，只要你不要让心受限，一切都有可能。 康德说：自律即自由。 先有自律，懂得隐忍和克制，放弃一些不重要的，坚持一些优秀的；而后才能因此获得真正的自由，成为自己想要的样子。 坚持一件能够让自己变好的事的确不容易，打磨自己的过程也总是充满了艰难和迷茫。 但只要你在朝前走，只要你在朝着更优秀的方向拼搏，即使最后失败，也是最难能可贵的经历。 思考、行动、自律、坚持，共勉。 要相信，勇于大步向前走的人，总能够找到属于自己的光亮。 第五条，有些人该放就放。 人生就像一条路，从起点出发，到终点结束，不长不短刚刚好。 但在开始时，我们因过于懵懂而无法抉择，可待到结束时，回望一生却总觉得有诸多悔恨。 其实未来和过去，都不是我们该看重的东西，时光飞逝，只该抓紧今日。 珍惜现在拥有的人和事，感恩如今生命馈赠的一切，得不到的就不要去想它，已经失去的，就赶紧放下吧。 有些事得过且过，有些人该忘就忘。 别因为一时的失意就沉沦放纵，也别把悲伤和难过郁结在心里。 生活本就很苦了，但你可以学着做自己的草莓味儿； 保持健康的身体和积极的心灵，从每一个当下开始，期许新生活。 第六条，先爱自己，而后爱人。 坚持读书，写字，听歌，旅行，上网，摄影，有时唱歌，跳舞，打扫，烹饪，约会，狂欢。” 无论遇见什么，人生都在照常运转，无论离开了谁，生活也不能停滞不前。 不懂先为自己付出的人，就算为别人掏心掏肺，也会被当作理所当然； 不懂先爱自己的人，就算把自己感动得痛哭流涕，也无法真正拥有合适的爱情和生活。 先爱自己，而后爱人。 如此，便能够为了开心而保持微笑，为了幸福而变得坚韧；如此便不会为了一个不值得的人伤神沉沦，不会为了不必要的事大动肝火。 只此一世，取悦自己，真的很重要。 希望你也成为这样的人，眼里长着太阳，笑里全是坦荡。余生漫漫，且行且成长，且行，珍惜。","link":"/夜读20191006/"},{"title":"记人恩，忘人过","text":"怀包容之心，还己一份轻松！活着不易，人人都有难处，做人，应常怀慈悲心，体谅他人的难处。人无完人，人人都有不足，常怀包容心，容纳万物，少计较，少对比，放过自己，不苛责他人，多去欣赏放大他人的优点，忽略他人的不足。 俗话说，烦恼天天有，不捡自然无，心宽一分云消雾散，让人一步晴空万里。 有一种心安，叫念人恩，有一种轻松，叫忘人过，帮过我们的，铭记于心，心宽，不念人过忘人错，不忘人恩，知恩图报，不记人过，心胸开阔，不思人非，不计人怨，踏实生活！ 心宽一尺，少记人过。 古人云：“一斗米养个恩人，一石米养个仇人。” 在生活中，总有这么一类人存在，你对他十次好，一次不顺心， 他就会抹杀所有，只记得你的过错，有些人习惯了索取，便忘记了付出、感恩。 在这个世界上并不是人人都懂“良心”两个字，纵然你有千般好，只要有一个不好，就推翻了你所有的付出；哪怕你为他倾尽所有，掏心掏肺，一个过错，就会揪着不放。 这类人，你帮他一百次却从不记恩，但半次不帮就记恨在心，永不忘怀。 人都是相互的，你怎么待人，别人也会以同样的方式待你，你待别人刻薄，别人就会远离你，你待他人真诚，别人就会珍惜你。 做人，靠心，不靠嘴，用真心待人，才能换得知己，用嘴巴待人，难以换得信任。 尺有所短，寸有所长，别拿自己的标准衡量人，别用自己的眼光审视人，人人都有不足，谁都不完美，挑人过错时，嘲笑他人的缺点时，先反省一下自身。 人活着，谁都不完美，都有难言的苦。别总是挑剔别人，不去反省自己的错误。 做人，理应用放大镜看别人的优点，用显微镜看自己的缺点，因为事事都不完美，别用自己的认知去评论一件事。 人人都有不足，别用自己的心胸去度人，用自己的心眼去要求他人，理应得饶人处且饶人，放过了别人，也等于放过了自己，怀包容之心，心宽一尺，还己一份轻松！ 常记人恩，知恩图报。 常言道：“别人帮你是情分，不帮你是本分。” 做人应有良心，常怀一颗感恩之心，不要因为别人一次拒绝你，就放在心上，揪着不放，人人都有为难之处，做人应换位思考，更不要把别人曾经对你的好抛却脑后。 不要因为一点小事，就否定别人之前对你的知遇之恩，就忘记别人对你所有的好。 在生活中，理应感恩每一次遇见、相逢、重逢。感恩每一个出现在我们生命里的人，因为他们都是我们生命中的贵人！ 感恩生我养我的爸妈，把我们带到人世间，给予我们生命；为我们扛起重担，教会我们做人的道理； 感恩老师，是他们无私的奉献和付出，一路启蒙、引导着我们。授予我们知识，助我们圆梦。念师恩，一生无悔！ 感恩朋友，当我们陷入低谷时，用真挚的友谊给予鼓励与安慰。当我们遇到麻烦时，及时伸出援助之手。当我们走投无路时，愿意倾囊相助。 君子重情不忘恩，小人重财记人过，懂感恩的，贵人助，记人过的，仇怨多。 古人云，滴水之恩，当涌泉相报，忘人过，记人恩，你的格局才会越来越大，人生之路才会越走越宽。 人活一世，如露水一朝，今生为人，好好踏踏实实做人。少记人过，常记人恩。 为人要诚恳，说话要中肯，做事要讲究诚信，说话算话；交人，要懂感恩，以心换心，将心比心。学会感恩，才会知足；学会感恩，才会保持恬淡自然的心态；学会感恩，才能看清自己，路才会更宽！","link":"/夜读20191007/"},{"title":"世界再大，也不如有人等你回家","text":"世界上最美的风景，是回家的路！最近，一则90秒的短片在朋友圈刷屏，让无数人为之动容。 夜晚，灯火阑珊。女主角依然为了工作忙得不可开交。 这样的情形，已经成了现代城市年轻人的一个缩影。 节日到了，母亲希望女儿回家一趟，言外之意还有让她相亲的意思。 但是女主角并不愿意父母干涉自己的事儿，无奈之下只好借口出游躲避回家后的“麻烦”。 当假期如约而至，女主角开始踏上自己的旅程。 旅途上的一个小插曲，无意间触动了她心中的那一份柔软： 高速路服务区，一位技工小哥，在帮她检测车辆的时候，收到了家中的电话。 为了坚守自己的岗位，方便大家的出行，就连节假日他也无法抽身回乡。与此同时，女主角的母亲也再次给她发来关心的短信。 直到这一刻女主角才发现，原来有些近在咫尺的幸福，于另外一些人而言，却是一种奢望。 视频的最后，当女主开始踏上回家旅程的那一刻，我的心中也仿佛有一块石头重重地落下。 原来，这个世界再大，也不如有人等你回家。 上周，我刚到办公室，就发现同事群里一阵骚乱。 原来国庆临近，很多同事都没有抢到火车票，有的撺掇着拼车回家，有的忙着发送抢票链接，一片慌乱。 在外工作多年，这样的场景早就是一种常态，本来我不以为意，但是同事小艾还是引起了我的注意。 小艾是公司来的新人，脾气倔得很，因为毕业后的择业问题与父母产生了一些矛盾，所以来北京这几年，即便步履维艰，她也很少回家。 但是这一次，我却见到了她在同事群连发了三条“求救信息”： “哥哥姐姐们，求加速，抢不到回家的车票啦。” 后面还缀上了一个大哭的表情。 后来，我们吃饭聊天，她说起这一件小事，不仅让她备受感动，恍然大悟，也让我感触颇深。 原来中秋的前一天是小艾的生日，她本以为自己又要孤独地长大一岁。可就在她上一秒还在和父母通电话，说放假不能回家时，公寓的门铃突然响起。 开门的那一刻，她无论如何都不会想到，外面站着的竟然是从千里之外风尘仆仆赶来的父母。 望着他们手里提着那盒她最喜欢吃的水果蛋糕，小艾瞬间泪目。 的确，父母和子女之间必将经历一场又一场的别离，但是彼此的爱不会因为距离而衰减。 他们希望你过得好，盼着你变强大，哪怕就此离家越来越远，他们也会想尽办法来到你的身边。 小艾最后告诉我：“以后每个假期我都要回家。”语气充满了坚定，也充满了幸福。 当我们努力去踏遍千山万水的时候，千万别忘了回头看一看那个随时等你回家的人。 你还记得上一次回家探望他们是什么时候吗？ 你还记得上一次打电话给他们是什么时候吗？ 你还记得上一次真正和他们敞开心扉聊天是什么时候吗？…… 很喜欢这样一首小诗： 我们的世界很大，常忽略了他们。父母的世界很小，只装满了我们。 他们经常忘了，我们已经长大。就像我们经常忘了，他们已经渐渐白发。 诚然，外面的世界很精彩，但父母绝对不应该成为被我们遗忘的一部分。 因为一直以来，只有他们才会用最笨拙的方式默默地守护着我们。 无论你身处何种境遇，父母对孩子总是充满了牵挂。 并且也终于发现不知不觉那个等自己回家的人已经渐渐老去，自己亏欠他们太多太多。 我们总说来日方长，可人生哪来那么多后会有期。 世间最美好莫过于：我已长大，你还未老；我有能力报答，而你仍然健康。 有人问“逢年过节，为什么中国人总要不远万里回家？” 知乎上有个高赞回答，只有一句话，却触动人心： 因为那是我的“家”呀，别的地方只能叫做“住的地方”。 在网上看到过这样一个故事： 因为刚刚毕业，女孩一直没能找到工作，到了年底想要回乡，身上只剩下几百块钱。 路途遥远，她买不起机票，只好买最便宜的绿皮火车票，需要在硬座上待三十几个小时。 等她终于赶回家乡的城市，早已经是凌晨一点。 但是没想到，她刚一出站，就看到了在站台上翘首以盼的父亲。 深夜的车站人烟稀少，父亲缩着脖子，哈气搓手。看到她出现，小跑着过来。 接过行李的时候，父亲说：“外面混得不好就回来，爸养你。长了不敢说，养你到40岁，爸还是有这个能力的。” 听到父亲的话，她特别想哭，心里一直堵着难过，在到家的那一刻，突然释放了。 有人说，家是一个有温度的词，它不仅是我们身体休息的地方，更是我们心灵停靠的港湾。倦鸟归林、鱼翔浅底、落叶归根，这都是对家的渴望，也是生命在追寻着的一种归宿。 你终会发现，你心中最美的风景，不是霓虹闪烁，也不是高楼大厦，而是那个有父母等你回去，无论贫穷或富有的家。","link":"/夜读20191005/"},{"title":"人，绝不能让心情生病","text":"能笑，就别选择哭！散文家林清玄的书法很好。 有一天，他的朋友向他讨要一副字，考虑再三，他写下了四个字：常想一二。 朋友问，这是什么意思？ 林清玄说了这样一段话：“人生不如意事十常八九，我们生命里不如意的事占了绝大部分，因此，活着本身是痛苦的。但扣除八、九成的不如意，至少还有一、二成是如意的、快乐的、欣慰的事。我们如果要过快乐的人生，就要常想那一、二成好事，这样就会感到庆幸、懂得珍惜，就不至于被八九成的不如意所打倒了。” 的确，生活里的大部分事，总是难熬痛苦的。 上学时，要日复一日地沉浸在学业里，每日都要为成绩提心吊胆。 工作后，既要承担沉重的经济压力，提起精神面对职场上的纷纷扰扰，又要照顾好一家老小，不管多累时间却好像总是不够用。 生活不如意之事太多了，哪怕艰难地挺过所有苦难，也不一定能有大欢喜降临。 可若是整日沉浸在对痛苦的厌恶、对压力的反感中，生活就会是灰蒙蒙的一片。 不如多想想那一二如意之事，哪怕快乐少有，也要记得快乐是什么样的味道，用这样的方式去生活，才会有阳光出现。 否则，心情生了病，生活也不会见好。 读过这样一则小故事。 有兄弟二人，大约四五岁。 因为卧室里的窗户总是密闭着，他们觉得室内太过暗沉，看到外面的阳光，很是羡慕，就想了一个主意：把阳光扫进来。 于是，他们拿着笤帚和畚箕去阳台扫阳光，但当他们把畚箕拿到屋里的时候，发现阳光没了。 他们尝试了很多次，还是没有阳光，开始着急。 这时妈妈看到了他俩奇怪的动作，问：“你们在做什么呢？” 两兄弟答道：“房间太暗了，我们想扫点儿阳光进来。” 妈妈笑了：“只要把窗户打开，阳光自然会进来，何必去扫呢？” 阳光就像我们的好心情，很多人知道它能驱散黑暗，带来温暖，能让日子欢快起来，很想努力拥有，却总是得不到。 但其实，当你真正放松下来，把封闭的心门打开，就会发现原来快乐并不难，阳光般的好心情自然而然就来了。 很多时候，我们总是把自己逼得太紧，什么都想要，什么都得不到，还把自己弄得一身狼藉。 适时放松一些，心情才不会那么容易就生病。 去看看云卷云舒，去赏赏春花秋叶，日子很美，只是我们习惯于沉浸在各种功名利禄里，忽略了心情的重要性。 人生短短几十年，总要活得开心些。 有个老太太喜欢买苹果，有次她买了一筐苹果，就找烂的吃掉，好的留到明天再吃，明天再找个烂的吃，好的再留着。 她不断地吃烂苹果，最后她吃掉了一筐烂苹果。 你看，其实生活就像那筐苹果，有烂的、也有好的，全看你先吃哪个。 先吃坏苹果，一天都会是坏心情，好苹果也会在你不经意间腐烂掉。 但先吃好苹果，至少当下的心情是欢快的。 我们无法把握明天，别把快乐都留在遥远的未来，因为生命无常，世事难料，谁也无法保证未来的你终会平安喜乐。 记住，不论昨天曾发生过什么事，也不论明天有什么即将来临，你永远“置身现在”。 一旦现在的心情生病了，就很难痊愈，未来的心情也会跟着受影响。 人只有活好每一个当下，用最好的心态去面对，人生之路才不会伴随太多悲叹，明天的快乐才会按时到达。 能笑，就别选择哭，能开开心心，就别抑郁低沉。想开了，一切就通畅了。 人，绝不能让心情生病。","link":"/夜读20191008/"},{"title":"无论和谁，都别熟得太快","text":"给双方的关系多一点空间，才能有更多的来日方长！有句话呀，说得很在理：“使人有乍交之欢，不若使人无久处之厌。” 相处不累、久处不厌的秘诀到底是什么呢？ 其中，有很重要的一点便是：无论和谁，都别熟得太快。 欲速则不达的道理，同样适用于人际关系。 与人相处，切莫交浅言深。 古语有言：“骃闻，交浅而言深者，愚也。” 刚认识没多久，连对方的人品都不清楚，就将自己最深处的想法和盘托出，是不明智的。 宋朝时期，有位李郎中，开了一家中药铺。 某天呢，有个突然得了怪病的人上门来，急匆匆地请李郎中治病。 李郎中也不负“妙手回春”之名，开了几贴药，便把病治好了。 病人亲自登门道谢，李郎中更是热情款待，备上了好酒好菜，两人相谈甚欢。 推杯换盏中，李郎中聊到了自己在朝为官的幼时的邻居，还连带地说起了这个邻居不为人知的糗事，两人一起哈哈大笑，惬意得很。 过了一段时间，李郎中的中药铺遭到了官府查封，不明所以的李郎中一经打探才知道，原来是先前的那位病人将邻居的糗事传开了去。 导致邻居身边的官员纷纷在私底下窃窃私语，取笑邻居。 一向好面子的邻居气不过，就伺机地找他麻烦。 断了门路的李郎中去质问病人，病人却说：“这是秘密吗？感觉我们刚认识不久，如果是不可见人的秘密，你又怎么会告诉我呢？” 李郎中被问得哑口无言，只怪自己当初对病人还不熟识，就畅所欲言，现在后悔也晚了。 人性难辩啊，与信任的人说话尚且得小心隔墙有耳，更何况对初相识的人呢？ 也许你叮咛着说要保密的事，他转身就告诉了别人；也许你敞开心扉、诉说衷肠，他未必就能感同身受。 到头来，怪得了谁呢？ 既然交情浅，话题又何必聊得太深入呢？ 这热情过了度啊，就会缺了边界。 在人际交往当中，最令人反感的便是多管闲事，别人不想他管，他偏要插一手。 不多管闲事，并非要求人冷漠，而是要把握好分寸。 有时候热情过了度，就容易逾越本分，触碰他人的底线。 阿强曾经分享了他的经历： 他搬到新家之后呢，认识了隔壁一对很热情的夫妇，黄阿姨属于自来熟的性格，第一天认识就过来帮忙，阿强满是心怀感激。 到了傍晚，收拾得差不多的时候啊，黄阿姨看到阿强家里的盆栽，跟他说摆在电视柜旁边不好看，让他挪到屏风的旁边，说那里的风水好。 阿强客气地再三拒绝，说有自己的考虑，可是黄阿姨却自己动起手来，一边挪动一边说：“你们这些年轻人，就是不懂这些。” 阿强无奈又有点儿生气，觉得黄阿姨管得过了头。 气氛也从一开始的其乐融融，变得最后的不欢而散。 有些事儿，可能是出于好心替人张罗，但每个人都有自己的想法，也都不希望别人对自己的生活横加议论和干涉。 有些话，点到为止即可，再多说，便是对他人隐私的冒犯。 太不把自己当外人，并不是耿直的真性情，有时反而会给别人带来麻烦和困扰。 熟得太快，就容易口无遮拦，言行举止没有分寸，这是人与人相处的禁忌。 热心的分寸没把握好，就容易被误认为是刻意讨好；友善的分寸没把握好，就容易被当成是有利所图；关心的分寸没把握好，就容易被认为是多管闲事。 结果呢，好心做了坏事，弄巧成拙，尴尬得很。 对于很多人来说，得体的待人处事，胜过毫无分寸的耿直。 不随意插手，不轻易造成别人的困扰，这样的关系才最舒服。 不将自己的想法强加在别人身上，尊重别人的生活，才是真正的修养。 到什么阶段做什么事，若操之过急，反而适得其反。 每一段感情也都有着它自然发展的规律，若是因一时着急而揠苗助长，只会得不偿失。 无论与谁相处，无论再怎么相见恨晚，也别熟得太快，给双方的关系多一点空间，这样才能有更多的来日方长。 慢一点，才能有更多的时间去了解彼此； 慢一点，才能有更多的机会去看清真心； 慢一点，才能久一点。 毕竟，来得快的东西，往往去得也快。 因此，不必着急，更无须担忧，慢一点的感情，经过岁月的推敲，耐得住时光流转，更能细水长流，走得更深更远。","link":"/夜读20191009/"},{"title":"心若向阳，无畏悲伤","text":"好好做事、好好爱自己，过往不恋，当下不杂，未来不迎！尼采说过一句话：“与恶龙缠斗过久，自身亦成为恶龙；凝视深渊过久，深渊将回以凝视。” 生活中，我们常常因为遭遇到痛苦和烦恼的困扰，而感到焦虑不安。 于是，我们不断地想要摆脱这些困扰，结果却更容易深陷其中。 但其实，人生这一趟旅途，必然伴随着坎坷、困境。 顾虑太多、对事情耿耿于怀，只会让我们举步维艰；学会释怀、一念放下，才能让我们更好地洒脱前行。 正所谓：心幸福，日子才轻松；人自在，一生才值得。 同事莉莉，人长得美，工作能力强。所以领导总是在会议上对她赞赏有加。 本来是一件好事，但有些同事却因此嫉妒她，觉得她抢了别人的功劳。于是在背后偷偷抹黑她，到处说她是用了手段才得到领导的赏识。 尽管办公室内谣言已经传得满城风雨，但莉莉依然从容淡定地忙碌着自己的工作，完全没有想要解释清楚、证明自己清白的意思。 有一次，我在打印室遇到她，耐不住性子问她：“外面一直传一些对你不好的话，对你影响挺大吧？为什么你不解释一下呢？” 她一边复印看资料，一边慢悠悠地回答我：“别人都说，解释就是掩饰。如果我激动地去争辩解释，就会有人说我强词夺理；如果我反唇相讥，就会有人说我恼羞成怒。所以，我何必解释那么多呢？我只管做好自己分内的事就够了。时间啊，自然会替我证明一切。” 是啊，在日常生活中，我们总是在意周边人对自己的看法。因为别人的一点质疑和指责，就轻易改变自己。宁愿受委屈，也要做别人眼中的“老好人”，活成他们喜欢的模样。 但其实，生活从来都是自己的，与他人无关。 与其一直委曲求全，不如洒脱点，勇敢做自己。 就像诗人但丁所说的那样：“走自己的路，让别人说去吧！” 有人说：以前总是去解释去理论，是怕——怕自己得罪人，怕自己被人灭了，怕那些不停蹿动的小感受。 现在不去解释，不去理论，还是怕——怕浪费自己的时间，怕自己模糊了焦点，怕影响了品尝现世生活的胃口。 生活的道路有千万条，我们不必过于听从别人的意见、在意别人的眼光、走别人安排的路。 每个人，只有选择自己最喜欢的那条路去走，才会觉得舒服开心。 做好自己、不解释，坚定地走好自己的路。 有人说：“过去再好，回不去；曾经再美，已逝去。” 诚然，不管过往是美好还是不堪，都已经成为了过去。若是步步回头，只会越走越累；活在当下，才能过得洒脱舒服。 一位富翁，在他51岁那年破产。他只好又去经营生意、拼命赚钱。没多久，他果然又赚了许多钱。 他的朋友因此很奇怪，问他：“你的运气为什么总是这么好呢？” 富翁说：“这不是我的幸运，而是我的秘诀。” 朋友急切地问道：“你的秘诀可以说出来让大家听听吗？” 富翁笑了：“当然可以。其实也是人人都可以做到的事情。我是一个乐观主义者，无论任何事情，我从来不抱悲观态度，看淡得失。对于过去，不会留念，只会感恩；对于未来，不会担忧，只会迎接。我相信，一个人如果懂得扔下包袱，珍惜时光、活在当下，一定可以获得成功的。” 的确如此。快乐与否，取决于我们计较多少；伤心与否，取决于我们在意多少。 有一句很经典的台词：“当你紧握双手，里面什么也没有；当你打开双手，世界就在你手中。” 这个世界上，没有解不开的心结，没有过不去的经历，只有走不出的自己。 我们要做的是，学会活在当下，凡事尽力而为；不执着于得失，懂得为生活做减法。 唯有这样，才能让我们在前行的道路上走得轻盈舒服。 愿你，往事不回头，余生不将就。 好好做事、好好爱自己，过往不恋，当下不杂，未来不迎。 凡事保持一颗平常心。 歌德说过：“人之幸福，全在于心之幸福。”正所谓，物随心转，境由心造。 一个人怎样想，就会怎么样的结果。人的心态，是决定人生命运的舵手。 生活之中，保持好心态，凡事以一颗平凡心相待，即使有情绪、失落也能积极面对，不沉溺其中。那么事物就会层层展开，随着心境的转换而变好。 所谓的大千世界，都是心性产生的幻象，非虚非实，应该早点看开、放下，平常心相待。 学会用一颗平常心去看待，人生才会变得更加平静和淡定。 平常心，是一剂良药。它是迈向成功的坚实根基、是改变命运的人生利器，更是收获幸福的心灵法宝。 你有什么样的心态，就会有什么样的人生。","link":"/夜读20191010/"},{"title":"你唯一可以炫耀的是健康","text":"让自己健康地活着，才是对生命最好的交代！一名女子和丈夫外出归家，发现门口坐着三位蓄着花白胡子的老者。 夫妻俩面面相觑，对他们说：“我不知道你们是什么人，但各位也许饿了，请随我进来吃些东西吧。” 不料，他们却摆摆手，其中一位老者解释道：“我的名字叫健康，这位的名字是财富，那位叫成功，你们可以进屋讨论一下，愿意我们当中的谁进去做客。” 于是，丈夫和妻子进屋里商量。 妻子说：“我们让财富进来吧，这样我们就有用不完的金银财宝啦！” 丈夫却不同意：“亲爱的，你看我最近工作不太顺利，我们还是请成功进来更妙！” 一旁的女儿也在倾听，她建议：“为什么不请健康进来呢？这样我们一家人身体健康，就可以幸福地生活在一起了呀！” 丈夫摸摸女儿的头，转身对妻子说：“听女儿的吧，去请健康进屋做客。” 妻子遂出门问道：“敢问哪位是健康？欢迎进来做客。” 健康起身向屋中走去，财富和成功两人也站起身来，紧随其后。 妻子诧异地问财富和成功：“我只邀请了健康，为什么两位也随同而来？” 两位老者捋捋花白的胡子道： 无论健康走到哪儿，我们都会陪伴他走到哪儿，因为我们根本离不开他。但如果你没请他进屋，我们两个不论是谁进来，很快就会失去生命和活力。 看完大家都恍然大悟，试想若是被邀请进去的是财富或成功中的任何一位，这家人即使收获了短暂的欣慰和惊喜，没了健康，过不了多久一切都是虚妄。 回头想想，换做是你，又会做出什么样的选择呢？ 我们也曾为了财富争得头破血流，恼了他人害了自己；也为成功披星戴月地付出，最后却没能熬过健康这一大坎。 都说健康好比数字1，财富、事业、家庭都是0，只有稳住了1，才有后面无数的0，反之，则一无所有。 做出选择之前，老天给了那一家人机会，越是心灵澄澈的人越能发现世间最重要的所在。 记住：不是因为你成功了，才有财富、有健康，而是因为有了健康才能获得成功、守住财富。 人这一生，从哭声中醒来，又在哭声中离开。与其追问什么是死亡，倒不如认真钻研如何好好活着。 知乎上有个提问：人到中年，什么最重要？ 一个高赞回答只有五个字：健康最重要。 的确，健康最重要。 可就是这么简单的道理，多少人要在熬坏了身体后，才会重视。 茨威格在《断头皇后》里说的：她那时候还太年轻，不知道所有命运赠送的礼物，早已在暗中标好了价格。 你追求生活幸福、事业有成、父母尚在……但却忘了，这一切的基础就是拥有一个健康的身体。 身体，才是奋斗的本钱，健康，才是我们这辈子最大的财富。 你前半生拼的命，后半生身体会加倍地还。 人啊，有什么别有病，缺什么也别缺健康！ 让自己健康地活着，才是对生命最好的交代。 繁华三千，弹指刹那，百年过后，不过黄沙一抔。 人生在世几十年，腰缠万贯也好，穷困潦倒也罢，都是过眼云烟，钱再重要，也要有命来耗。 随着年龄的增长，你会发现，长时间熬夜后，头晕眼花，全身乏力，是你补再多觉也赶不走的黑眼圈； 你会发现，每逢换季时常腰背酸痛，视力开始模糊，记忆力也在衰退，干什么都提不起劲。 我们总是努力工作，拼命赚钱，到最后钱没赚到，人却病倒了，这是花再多钱也买不回身体原件。 朋友圈看过一段话：不要晒你的钱，到了医院，钱都不值钱；不要晒你的工作，倒下了，无数人会比你做得更出色；不要晒你的房，人走了，那就是在为别人做嫁衣裳；你唯一可以炫耀的，只有你的健康！ 拥有健康，财富才会慢慢堆积；拥有健康，成功才更有意义；拥有健康，幸福才能常相伴。 累的时候，别硬撑，该放手时就放手；困的时候，别熬夜，养成规律的睡眠习惯。 人生百年，犹如一瞬。 岁月给予我们的，不仅是风尘暗、朱颜改，还有山山水水，风花雪月。 愿你在有限的时光里，好好吃饭，好好睡觉，健健康康比什么都重要。","link":"/夜读20191011/"},{"title":"当你老了，这才是幸福","text":"幸福，其实一直在！毕淑敏曾在书中写过这样一个故事： 某个报社在报纸上进行一个征集，题目是“谁是世界上最幸福的人”。很快，成千上万的信函就汇集在了报社，报社组织了一个评选委员会，按照得票的多少，评选出票数最高的四位。 第一位：给孩子刚刚洗完澡，怀抱婴儿面带微笑的母亲。 第二位：给病人做完了一例成功手术，目送病人痊愈出院的医生。 第三位：在海滩上筑起了一座沙堡，望着自己劳动成果微笑的孩童。 第四位：写完了小说最后一个句号，合上了稿件的作家。 毕淑敏看到这些温暖的答案以后，心里却充满了悲伤，在过去的日子里，这四种幸福在她的身上其实都曾经历过。 她是个母亲，有给孩子洗过澡，有抱他在怀的时候； 她原来是医生，也有治好病人目送病人出院的时候； 她曾有过在工地上的沙堆挖过坑，恶作剧玩闹的时候； 她也出版过很多作品。 之所以感到悲伤，是因为自己身处在幸福之中，却感受不到幸福，发现不了幸福，更没有珍惜过幸福。 毕淑敏的这段感悟给了很多读者启示，也让很多身在福中不知福的人幡然醒悟。 生活中，多少人因为功名利禄等身外之物奔忙，为了爱恨情仇折磨自己，往往等到年华渐去，才发现自己在不必要的事物上，蒙蔽了双眼，浪费了太多时光。 其实，一生很短，别等你老了，才知道这些是幸福。 做想要做的事情，是幸福。 随着生活节奏的加快，很多人总是每日沉浸在担忧中，害怕自己跟不上多数人的脚步，害怕自己是脱离群众的“异类”。 殊不知，每个人有每个人的活法，有时候过于在意别人的看法，是一种负累，如果你不肯舍下沉重的心理负担，劳苦烦愁便会时刻围绕着你。 真正的幸福，往往不是你获得了多大的成功，或者被多少人喜欢，而是坚持自己的初心，做自己真正想要做的事情、走自己真正想走的路，才不负人世这一遭。 家人常伴在侧，是幸福。 不管你在何方，家都是你最温暖的港湾，是你前行路上最坚强的后盾。 不管你多疲惫，家人都是最了解你的人，他们能感同身受你笑容背后的苦。 与家人在一起，平淡的日子都是难得的幸福。 世事无常，有时间多给家人一些陪伴，别总想着等有时间了再去珍惜，更别等到所有的爱成了无法弥补的遗憾，再去无限追悔逝去的时光。 拥有健康的身体，是幸福。 有人说，当你觉得自己不够幸福、或是觉得命运待自己不公平的时候，就去凌晨两点半的医院，看看那些饱受病痛折磨的人，听听那些无法抑止的呻咛。 话虽残酷，却不无道理。 人世间生存的艰难，让许多人将生死置之度外，侥幸地以为健康能够永远透支，以至于让病痛一点点蚕食自己，离幸福越来越远。 但其实，世界上最不该被忽视的东西，就是你的健康，只有拥有健康的身体，才能更好地享受生命里的种种美好。那种种小美好组织在一起，就是我们也许从未曾察觉到的幸福。 犹记得年少时读过的一则小寓言故事：一只小狗每天都喜欢追逐自己的尾巴，可是却从未能真正碰触到。有一天，它突然问妈妈，“妈妈，到底我的幸福在哪里呢？” 妈妈微笑地看着它，“幸福就在你的尾巴上啊，虽然你感觉从未碰触得到，但是它一直跟在你的身后。” 岁月疾走，年华老去，短暂的一生中，有许多微小的幸福一直陪伴着我们：有喜欢做的事、有健康的身体、有爱你的和你爱的人相伴，这就是幸福，别等老了才知道！","link":"/夜读20191012/"},{"title":"让你永不发脾气的5个字","text":"把情绪放一放，你面对的可能是另外一个结局！人生在世，七情六欲在所难免。谁都无法避免遇到让自己愤怒、无奈的事。然而，如果不懂得克制自己的脾气，很容易就成为情绪的奴隶，无形中伤人伤己。 尼采就曾说过：“必须想方设法控制自己的感情、情绪，不让它随便乱动。若是放任不管，就会被它牵着鼻子走，或被它冲昏头脑。” 能够控制情绪，是一个人情商的最高体现，以下5个字，是让你永不发脾气的诀窍。 第一个字：忍。 人非圣贤，谁也不能时刻都保持良好状态，但是，谁都可以通过不断的学习和改善，来慢慢调整自己，降低发脾气的频率。 常言道，忍一时风平浪静，退一步海阔天空。忍耐并不是懦弱的妥协，而是大事化小的智慧，是为了更专心走好自己的路。 第二个字：静。 容易冲动的人，很难管住自己的嘴，终日抱怨连天、喋喋不休。 殊不知，祸从口出、言多必失，如果抱怨太多，每天都处在烦躁不堪的状态，福气也就少了。 人活着，说得多不如想得远，学会沉着看待事物，学会冷静思考是非，才能在浮躁的生活里，找到属于自己的宁静。 第三个字：淡。 很多时候，人之所以感到愤怒，是因为被欲望支配，看不清自己真正想要的是什么。 正所谓，欲望越大，得失心越重，越难以获得快乐。丢失了原有的洒脱与随性，学会看淡和知足，才会离幸福更近一些。 第四个字：宽。 如果一个人总是因为一点小事就斤斤计较，心中时刻充斥着不满，哪有剩余的精力去感恩别人的付出，体验世间的美好。 记得雨果有一句广为流传的话：“世界上最宽阔的是海洋，比海洋更宽阔的是天空，比天空更宽阔的是人的心灵。” 人生最大的修养就是宽容，你若心宽似海，清风自能常伴。 第五个字：平。 唐朝有位高僧名叫拾得，一日他的朋友寒山问他：“世人谤我、欺我、辱我、笑我、轻我、贱我、恶我、骗我，我该怎么办呢？” 拾得回答说：“那你只需忍他、让他、由他、避他、耐他、敬他、不要理他，再过几年，你且看他。” 人生短短几十年，何必跟自己过不去。保持一颗平常心，接纳生活的磨难，保持一颗慈悲心，看淡旁人的诋毁与中伤，平和地看待这个世界，平静地对待自己的委屈，修一颗平常心。 永远记得，生活就像一面镜子，你用什么心态去面对它，它便会怎样去面对你，时刻保持内心的谦卑平和，你终会被这个世界善待。 人生天地之间，若白驹过隙，忽然而已。 生命中有那么多美好的事情等待我们去发现，不要把时间浪费在无谓的事情上。为一件事发脾气，到头来自己的心也会很累，有时还会口不择言，不仅伤了身边的人，说后自己也常觉得后悔。 人无完人，总有一瞬间忍不住要发脾气，不妨试着把想说的话留在明天说，想讨论的话题留在明天再议。把情绪放一放，你面对的可能是另外一个结局。 我们要做情绪的主人，而不是任由情绪主宰。当你可以控制情绪的时候，你会发现，一切正如那句诗一样： 回首向来萧瑟处，归去，也无风雨也无晴。","link":"/夜读20191013/"},{"title":"活在当下，给自己找到一个恰到好处的位置","text":"有一部电影叫《遗愿清单》，讲了一个身价千万的富人和普通的汽车维修工同时患上了癌症，住进了一家医院，他们俩在病床上等待着即将来临的死亡，临终前回忆自己的一生真的过得快乐吗？ 富人一辈子为事业打拼，离过几次婚，不缺女人，尽管有钱但也没有真正的朋友和亲人，所以感到内心空虚，穷人一辈子抚养三个孩子，为了孩子放弃了很多自己喜欢的东西，省吃俭用把自己的一生奉献给了家庭，而自己还有很多遗憾。他们两个身份地位截然不同，但是在死亡面前却是平等的。 于是二人决定在人生最后的6个月里列下遗愿清单，为自己活一次，去做这一辈子觉得遗憾的事。 他们去高空跳伞，去飙车，去万里长城，去埃及金字塔，去埃塞俄比亚看野生动物，去喜马拉雅山目睹神迹，去出于善意帮助陌生人，去亲吻世界上最美的女孩，一段看世界的游历过后他们把最后的时光留给了家人。 他们收获了整个世界，最重要的事在人生最后的阶段，拥有了一段真挚无比的友情。 去世后他们二人的骨灰装在了最爱的咖啡罐头里，埋在了喜马拉雅山上。 电影带有浪漫的戏剧色彩，但也给我们的生活带来一些思考，人的生命有限，要在有限的生命里尽可能的去充实自己，去做自己喜欢的事，我们没有办法决定人生的长短，但至少可以决定人生厚度。 无论贫穷还是富贵，走到人生边上的时候，才发现人生被太多物质的外在的事物捆绑，而真正让自己快乐的是为自己活一次，我们甚至不知道明天和死亡哪一个先来，活在当下，做自己想做的事，去经历这段人生后所收获的爱情、友情、亲情。 我时常会想到人生，想到死亡。 在苍茫的宇宙里，如果有一双眼睛要怎样才能找到我，比一粒尘埃还要细微，即便是珠穆朗玛峰乃至整个地球，在银河系在星系团中也是沧海一粟。人类的微不足道常常让我产生一种虚无感，感觉活着做的一切都没有意义。 放大了尺度来看，生活即使虚无的，每个人都在命运的摆布下无力的生活着。恰恰因为如此，我们就应该活在当下，因为我们只存在于当下，人生是由无数个当下组成的，人应当在短暂的生命力找到自己恰到好处的位置。 我喜欢的作家张晓风在她新书《回首风烟》里阐述了她对自然的存在，生命的存在、时间的存在的哲学思辨，她写道：树在，山在，大地在，岁月在，我在。你还想要怎样更好的世界。她在书中用暖心的笔墨描绘她一生中的见闻和感悟，用人生大半辈子的经历告诫我们处事的智慧和乐观的生活态度。热爱当下的生活，享受当下的人生。 宇宙是浩瀚的，人生是虚无的。那我们生活的意义就在于，在当下有花草树木，有山水江河，有时间流淌，有爱人，有自己，尽管随着时间流转这些将会消逝，但至少当下这些是难得可贵的，是美好的。 把握住当下，活在现在，找准自己的位置，去行动，去感受自然，去珍惜身边可贵的人们，生命才会变得更加充实，自在。 有个故事这样讲道：有个小和尚，每天早上负责清扫寺院里的落叶。 清晨起床扫落叶实在是一件苦差事，尤其在秋冬之际，每一次起风时，树叶总随风飞舞。每天早上都需要花费许多时间才能清扫完树叶，这让小和尚头痛不已。他一直想要找个好办法让自己轻松些。 后来有个和尚跟他说：“你在明天打扫之前先用力摇树，把落叶统统摇下来，后天就可以不用扫落叶了。”小和尚觉得这是个好办法，于是隔天他起了个大早，使劲地猛摇树，这样他就可以把今天跟明天的落叶一次扫干净了。一整天小和尚都非常开心。 第二天，小和尚到院子里一看，他不禁傻眼了。院子里如往日一样满地落叶。 老和尚走了过来，对小和尚说：“傻孩子，无论你今天怎么用力，明天的落叶还是会飘下来。” 小和尚终于明白了，世上有很多事是无法提前的，不管人们怎么为未来担忧，也无法避免未来的可能性，惟有认真地活在当下，做好今天的每一件事，未来的交给未来的自己，才是最真实的人生态度。 克里希拉姆提说过：“所谓活在当下，就是在刹那间领会其中的美与喜悦，而不眷恋它所带来的快感。” 就像我们去看绘画展览，很多人路过一个景点就赶紧拿出手机拍照，希望留作纪念，想着能够给未来的自己看，而却忽视了这幅作品在你面前的那一刻给你带来的震撼和思考。 世界上有很多美转瞬即逝，有很多人匆匆路过就再也遇不见，所以我们要找准自己的位置，不要多虑未知之事，不要去奢望不能之事。做好当下的事，不要去等，去尽可能的去做想做之事。 因为当这个世界把自己呈现在我们面前的那一刻，我们可以喊出：我在！","link":"/美文20191006-01/"},{"title":"向美好的方向走，总有一天会遇见美好","text":"向着秋季的深处走去，夜晚的风凉快了许多。城市依旧车来人往的忙碌，很久没有抬头看月亮，低头走路久了，竟然忘记了许多美好的事物。 路上的车流排成一道风景，车灯点亮城市的夜空，在城市里即便是独处，身体也是不寂寞的，而让我们感觉孤独的是自己的内心。循着生命之路，走下去，也许这个秋天只是一段时光。 好多人总说“余生还长，无需慌张”，不尽然，一生真的不长，就在日月的交替里，我们不知不觉就从年少走到老去。弹指一挥间，往事皆如烟。 只有认真的感受此刻自己的生活，才不辜负时间的好。 年少不识愁滋味，为赋新诗强说愁。而今年华渐老，几多忧愁却难于开口。也只能安慰自己说，越来越成熟。其实所谓的成熟是我们不得不去深沉地对待生活。如果能有命运的厚爱，我们还是乐于一直做少年时那种无忧无虑的纯真。 在生活的行板上，遇见风和日丽，遭遇惊涛骇浪，不能停止的行程里，就连笑容也逐渐坚硬起来。每一位老者的表情都是肃穆而和蔼的，因为他们看过了人间的繁华和凄凉，懂得了敬畏和包容。 于是，在老去时又回归了孩童的童真，放下了一切身心的包袱。生命是一场轮回，从出生时的无知无识而纯粹，到老去时的看透和放下而活得纯粹。生命是神秘的，没有两个相同命运的人，它时时刻刻发生着变化，一步一步走下去，错过的风景再也回不到过去，所以心怀敬畏，珍惜当下。 时光里的美好，无处不在。路边开着的小野花，手中翻阅的书香，天上的月亮，河流在唱歌，小动物们那么可爱，晚风拂来清爽宜人，这一切的美好，都是对生命最厚实的赠予。你若不善待美好，那么美好将离你而去。 人在最努力的时候最好运，心存敬畏，在生命的历程中，认真坚持，才能成就更好的自己。当时对于写作的坚持源于作家林清玄的一番话，那天坐在一辆出租车上，收音机里的他很诚恳地说：“自己每天坚持写三千字，对他来说，已经是一种习惯了。”于是我尝试着每天坚持写一千字，日积月累在我写作的时候忽然发现很多时候写作不再枯涩，而是一种习惯。只要足够用力，生命的长度就会增加。 生活不是一床温软的被子，永远温暖踏实。它也有带给我们伤痛的时候，我们用心爱过的人，都成了彼此的亲人，彼此成了彼此的肌肉，骨头，血液，在分别的时候，痛彻心扉。太多我们不能掌控的事情在发生，无能为力中，只有心痛难忍。 时光是一个万花筒，转呀转就画出一幅美丽的画面，而生活的真相里，是残酷的现实。对待时光里发生的所有，始终保持热情。多向美好的方向走，总有一天我们会遇见美好。 秋夜的风吹来，每一盏灯火下都有自己的故事。我们不能替代别人的生活，别人也不能和自己感同身受。唯有在真实的生活里，认真地去对待，用最真的心去对待身边的人和这个世界。 始终保持敬畏之心，对时光，对美，对痛楚，永远去爱。","link":"/美文20191007-01/"}],"tags":[{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"JSON.stringify","slug":"JSON-stringify","link":"/tags/JSON-stringify/"},{"name":"JSON.parse","slug":"JSON-parse","link":"/tags/JSON-parse/"},{"name":"call/apply/bind","slug":"call-apply-bind","link":"/tags/call-apply-bind/"},{"name":"柯里化","slug":"柯里化","link":"/tags/柯里化/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"节流/防抖","slug":"节流-防抖","link":"/tags/节流-防抖/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/深拷贝/"},{"name":"继承","slug":"继承","link":"/tags/继承/"},{"name":"instanceOf","slug":"instanceOf","link":"/tags/instanceOf/"},{"name":"夜读","slug":"夜读","link":"/tags/夜读/"},{"name":"美文","slug":"美文","link":"/tags/美文/"},{"name":"励志","slug":"励志","link":"/tags/励志/"}],"categories":[{"name":"javaScript","slug":"javaScript","link":"/categories/javaScript/"},{"name":"面试","slug":"面试","link":"/categories/面试/"},{"name":"夜读","slug":"夜读","link":"/categories/夜读/"},{"name":"面试","slug":"javaScript/面试","link":"/categories/javaScript/面试/"},{"name":"JavaScript","slug":"面试/JavaScript","link":"/categories/面试/JavaScript/"},{"name":"美文","slug":"夜读/美文","link":"/categories/夜读/美文/"},{"name":"美文","slug":"美文","link":"/categories/美文/"},{"name":"算法","slug":"javaScript/面试/算法","link":"/categories/javaScript/面试/算法/"}]}