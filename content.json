{"pages":[{"title":"关于我！","text":"大家好，我是一名前端工程师，每天会根据时间更新一下自己的博客，内容是自己所学亦或是从别处理解之个人见解，前端道路漫长，有趣之中也会有很多烦躁，合理安排时间，坚持下去，未来的我们终究会感谢现在的自己，加油，打工人！","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"link","text":"","link":"/link/index.html"}],"posts":[{"title":"localStorage与sessionStorage简易ES6封装","text":"本文主要是对localStorage与sessionStorage进行简易的封装，有需要的小伙伴请自取！直接上代码// 此为storage.js文件class Store { constructor (store) { // 检测是否支持localstorage if (!store) { console.log('不支持localStorage') return; } this._store = store; } /** * @function 设置值 * @param {string} _k 必须参数，属性 * @param {any} _v 非必须参数，属性值 */ setItem (_k, _v) { if (!this._store) return; let kType = this.getType(_k); if (kType === 'string') { this._store.setItem(_k, this.filterValue(_v)); } else { console.log('key只能为字符串！'); } } /** * @function 获取值 * @param {string} _k 必须参数，属性 */ getItem (_k) { if (!this._store) return; let res; let kType = this.getType(_k); if (kType === 'string') { res = this._store.getItem(_k); } else { console.log('key只能为字符串！'); } return res; } /** * @function 移除值 * @param {string} _k 必须参数，属性 */ removeItem (_k) { if (!this._store) return; let kType = this.getType(_k); if (kType === 'string') { res = this._store.removeItem(_k); } else { console.log('key只能为字符串！'); } } /** * @function 移除所有 */ clear () { if (!this._store) return; this._store.clear(); } /** * @function 判断类型 * @param {any} para 必须参数，判断的值 */ getType (para) { let type = typeof para; if (type === 'number' &amp;&amp; isNaN(para)) return 'NaN'; if (type !== 'object') return type; return Object.prototype.toString .call(para) .replace(/[\\[\\]]/g, '') // eslint-disable-line .split(' ')[1] .toLowerCase() } /** * @function 过滤值 * @param {any} val 必须参数，过滤的值 */ filterValue (val) { let vType = this.getType(val); let nullVal = ['null', 'undefined', 'NaN']; let stringVal = ['boolen', 'number', 'string']; if (nullVal.indexOf(vType) &gt;= 0) return ''; if (stringVal.indexOf(vType) &gt;= 0) return val; return JSON.stringify(val); }}class LocalStorage extends Store { constructor (store) { // eslint-disable-line super(store); } WX_USER_ID = 'WX_USER_ID';}class SessionStorage extends Store { constructor (store) { // eslint-disable-line super(store); } WX_SSO_TITLE = 'WX_SSO_TITLE';}const lStorage = new LocalStorage(window.localStorage || localStorage)const sStorage = new SessionStorage(window.sessionStorage || sessionStorage)export { lStorage, sStorage}使用方式:import { lStorage, sStorage } from './storage.js'lStorage.setItem(lStorage.WX_USER_ID, ['val']);lStorage.getItem(lStorage.WX_USER_ID); // ['val']","link":"/allArticles/localStorage与sessionStorage简易ES6封装/"},{"title":"手写算法之每日一题","text":"","link":"/allArticles/手写算法之每日一题/"},{"title":"详解promise、async和await的执行顺序","text":"题目和答案下面这段 promise、async、await 代码，请问控制台打印的顺序？async function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");}async function async2() { console.log(\"async2\");}console.log(\"script start\");setTimeout(function () { console.log(\"setTimeout\");}, 0);async1();new Promise(function (resolve) { console.log(\"promise1\"); resolve();}).then(function () { console.log(\"promise2\");});console.log(\"script end\");上述，在 Chrome 66 和 node v10 中，正确输出是：script startasync1 startasync2promise1script endpromise2async1 endsetTimeout显然，这考察的是 js 中的事件循环和回调队列。注意以下几点：Promise优先于 setTimeout宏任务。所以，setTimeout回调会在最后执行。Promise一旦被定义，就会立即执行。Promise的 reject和 resolve是异步执行的回调。所以， resolve()会被放到回调队列中，在主函数执行完和 setTimeout前调用。await执行完后，会让出线程。async标记的函数会返回一个 Promise对象.最令人困惑的，就是 async1 end在 promise2之后输出.在函数 async1中，执行 promise（由于 async2是 async标记的函数，所以默认返回 promise对象）会发现 resolve()，然后放入回调队列。接着执行下方的 new Promise中的 resolve()输出 promise2，再回来输出 async1 end。其中，async1函数可以写成以下方式（便于理解）：async function async1() { console.log(\"async1 start\"); async2().then((_) =&gt; { console.log(\"async1 end \"); });}流程1、console.log(‘script start’)输出：script start.2、setTimeout 被放在最后调用.3、执行 async1 函数，输出 async1 start。然后，进入 async2 函数，输出 async2，并返回 Promise 对象。回到 async1，由于 await，让出线程，async2 函数返回的 Promise 放在回调队列.4、新 new 了一个 Promise 对象，输出 promise1。其中的 resolve()被放在回调队列.5、console.log(‘script end’)输出：script end.6、执行回调队列中，async1 返回的 Promise 对象，对象产生的 resolve 被放入对调队列。这里不输出任何值.7、执行回调队列中，下方 Promise 显式声明的 resolve，输出 promise2.8、执行回调队列中，由于 async1 函数返回的 promise 对象的 resolve，输出 async1 end.9、执行回调队列中，最后的 setTimeout，输出 setTimeout10、finish.","link":"/allArticles/详解promise、async和await的执行顺序/"},{"title":"JS面试中常见的算法题","text":"js除了基础知识以外，算法也是挺重要的。因此特意整理了一些常见的算法题，希望大家有帮助！1、验证一个数是否是素数如果这个数是 2 或 3，一定是素数；如果是偶数，一定不是素数；如果这个数不能被3~它的平方根中的任一数整除，m必定是素数。而且除数可以每次递增（排除偶数）。function isPrime(num){ if (num === 2 || num === 3) { return true; }; if (num % 2 === 0) { return false; }; let divisor = 3,limit = Math.sqrt(num); while(limit &gt;= divisor){ if (num % divisor === 0) { return false; } else { divisor += 2; } } return true;}console.log(isPrime(30)); // false2、斐波那契最简单的做法：递归。function fibonacci(n){ if (n &lt;= 0) { return 0; } if (n == 0) { return 1; } return fibonacci(n-1) + fibonacci(n-2);}但是递归会有严重的效率问题。比如想要求得f(10)，首先需要求f(9)和f(8)。同样，想求f(9)，首先需要f(8)和f(7)…这样就有很多重复值，计算量也很大。改进：从下往上计算，首先根据f(0)和f(1)计算出f(2)，再根据f(1)和f(2)计算出f(3)……以此类推就可以计算出第n项。时间复杂度O(n)。function fibonacci(n){ let ori = [0,1]; if (n &lt; 2) { return ori[n]; }; let fiboOne = 1,fiboTwo = 0,fiboSum = 0; for (let i = 2; i &lt;= n; i++) { fiboSum = fiboOne + fiboTwo; fiboTwo = fiboOne; fiboOne = fiboSum; } return fiboSum;}console.log(fibonacci(5));3、求最大公约数除数 在a和b的范围内，如果同时a和b处以除数的余等于0，就将此时的除数赋值给res；除数自增，不断循环上面的计算，更新res。function greatestCommonDivisor(a, b){ let divisor = 2,res = 1; if (a &lt; 2 || b &lt; 2) { return 1; }; while(a &gt;= divisor &amp;&amp; b &gt;= divisor){ if (a%divisor === 0 &amp;&amp; b%divisor === 0) { res = divisor; } divisor++; } return res;};console.log(greatestCommonDivisor(8, 4)); // 4console.log(greatestCommonDivisor(69, 169)); // 1解法2function greatestCommonDivisor(a,b){ if (b === 0) { return a; } else { return greatestCommonDivisor(b,a%b); }};4、数组去重对原数组进行遍历获取arr[i]的值 j；对应到辅助数组 exits 的位置 j 的值，如果没有，则证明arr[i] 的值没有重复，此时将 值j 存入res数组，并将辅助数组 j 位置的值置为true。最后返回res数组。function removeDuplicate(arr){ if (arr === null || arr.length &lt; 2) { return arr; }; let res = [],exits = []; for(let i = 0; i &lt; arr.length; i++){ let j = arr[i]; while( !exits[j] ){ res.push(arr[i]); exits[j] = true; } } return res;}console.log(removeDuplicate([1,3,3,3,1,5,6,7,8,1])) // [1,3,5,6,7,8]5、删除重复的字符这一题的解法和上一题类似。function removeDuplicateChar(str){ if (!str || str.length &lt; 2 || typeof str != \"string\") { return; }; let charArr = [],res = []; for(let i = 0; i &lt; str.length; i++){ let c = str[i]; if(charArr[c]){ charArr[c]++; } else{ charArr[c] = 1; } } for(let j in charArr){ if (charArr[j] === 1) { res.push(j); } } return res.join(\"\");}console.log(removeDuplicateChar(\"Learn more javascript dude\"));6、排序两个已经排好序的数组如果 b数组已经遍历完，a数组还有值 或 a[i] 的值 小于等于 b[i] 的值，则将 a[i] 添加进数组res，并 i++；如果不是上面的情况，则将 b[i] 添加进数组res，并 i++；function mergeSortedArr(a,b){ if (!a || !b) { return; }; let aEle = a[0],bEle = b[0],i = 1,j = 1,res = []; while(aEle || bEle){ if ((aEle &amp;&amp; !bEle) || aEle &lt;= bEle) { res.push(aEle); aEle = a[i++]; } else{ res.push(bEle); bEle = b[j++]; } } return res;}console.log(mergeSortedArr([2,5,6,9], [1,2,3,29])) // [1,2,2,3,5,6,9,29]7、字符串反向function reverse(str){ let resStr = \"\"; for(let i = str.length-1; i &gt;= 0; i--){ resStr += str[i]; } return resStr;}console.log(reverse(\"ABCDEFG\"));function reverse2(str){ if (!str || str.length &lt; 2 || typeof str != \"string\") { return str; }; let res = []; for(let i = str.length-1; i &gt;= 0; i--){ res.push(str[i]); } return res.join(\"\");}console.log(reverse2(\"Hello\"));将函数添加到String.prototypeString.prototype.reverse3 = function(){ if (!this || this.length &lt; 2) { return; }; let res = []; for(let i = this.length-1; i &gt;= 0; i--){ res.push(this[i]); } return res.join(\"\");}console.log(\"abcdefg\".reverse3());8、字符串原位反转例如：将“I am the good boy”反转变为 “I ma eht doog yob”。提示：使用数组和字符串方法。function reverseInPlace(str){ return str.split(' ').reverse().join(' ').split('').reverse().join('');}console.log(reverseInPlace('I am the good boy'));9、判断是否是回文function isPalindrome(str){ if (!str || str.length &lt; 2) { return; } for(let i = 0; i &lt; str.length/2; i++){ if (str[i] !== str[str.length-1-i]) { return false; } } return true;}console.log(isPalindrome(\"madama\"))10、判断数组中是否有两数之和eg：在一个未排序的数组中找出是否有任意两数之和等于给定的数。给出一个数组[6,4,3,2,1,7]和一个数9，判断数组里是否有任意两数之和为9。eg：在一个未排序的数组中找出是否有任意两数之和等于给定的数。给出一个数组[6,4,3,2,1,7]和一个数9，判断数组里是否有任意两数之和为9。function sumFind(arr,num){ if (!arr || arr.length &lt; 2) { return; }; let differ = {}; for(let i = 0; i &lt; arr.length; i++){ let subStract = num - arr[i]; if (differ[subStract]) { return true; } else{ differ[arr[i]] = true; } } return false;}console.log(sumFind([6,4,3,2,1,7], 9)); // true11、连字符转成驼峰如：get-element-by-id 转为 getElementByIdlet str = 'get-element-by-id';let arr = str.split('-');for(let i=1; i&lt;arr.length; i++){ arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1);}console.log(arr.join('')); // getElementById12、加油站问题-贪心算法一辆汽车加满油后可行驶n公里。旅途中有若干个加油站。设计一个有效算法，指出应在哪些加油站停靠加油，使沿途加油次数最少。对于给定的n(n &lt;= 5000)和k(k &lt;= 1000)个加油站位置，编程计算最少加油次数。并证明算法能产生一个最优解。要求：输入：第一行有2个正整数n和k，表示汽车加满油后可行驶n公里，且旅途中有k个加油站。接下来的1 行中，有k+1 个整数，表示第k个加油站与第k-1 个加油站之间的距离。第0 个加油站表示出发地，汽车已加满油。第k+1 个加油站表示目的地。输出：输出编程计算出的最少加油次数。如果无法到达目的地，则输出”NoSolution”。function greedy(n, k, arr){ // n:加满可以行驶的公里数; k:加油站数量; arr:每个加油站之间的距离数组 if (n == 0 || k == 0 || arr.length == 0 || arr[0] &gt; n) { return \"No Solution!\"; // arr[0] &gt; n ：如果第一个加油站距离太远，也无法到达 }; let res = 0, distance = 0; // res：加油次数；distance：已行驶距离 for(let i = 0; i &lt;= k; i++){ distance += arr[i]; if (distance &gt; n) { // 已行驶距离 &gt; 加满可以行驶的公里数 if(arr[i] &gt; n){ // 如果目前加油站和前一个加油站的距离 &gt; 加满可以行驶的公里数，则无法到达 return \"No Solution!\"; }; // 可以在上一个加油站加油，行驶到目前的加油站i： distance = arr[i]; res++; // 加油次数+1 } } return res;}let arr = [1,2,3,4,5,1,6,6];console.log(greedy(7,7,arr)) // 413、用正则实现trim() 清除字符串两端空格String.prototype.trim1 = function(){ // return this.replace(/\\s*/g,\"\"); // 清除所有空格 return this.replace(/(^\\s*)|(\\s*$)/g,\"\"); // 清除字符串前后的空格};console.log(\" hello word \".trim1()) // \"hello word\"14、将数字12345678转化成RMB形式：12,345,678思路：将字符串切割成数组再反转，遍历数组，加入辅助数组，当数组长度为3的倍数，再向辅助数组加入 “,”。function RMB(str){ let arr = str.split(\"\").reverse(); let res = []; for(let i = 0; i &lt; arr.length; i++){ res.push(arr[i]); if ((i + 1) % 3 === 0) { res.push(\",\"); } } return res.reverse().join(\"\");}console.log(RMB(\"12345678\"))15、删除相邻相同的字符串function delSrt(str){ let res = [], nowStr; for(let i = 0; i &lt; str.length; i ++){ if (str.charAt(i) != nowStr) { res.push(str.charAt(i)); nowStr = str.charAt(i); } } return res.join(\"\");}console.log(delSrt(\"aabcc11\"))","link":"/allArticles/JS面试中常见的算法题/"},{"title":"观察者模式与发布订阅模式","text":"随着Vue3的发布，各大论坛和公众号都是与之对比的文章，讨论最多的就是响应式原理的实现，借此机会，重新学习了一下设计模式中的观察者模式和发布订阅模式，下面再来回顾一下！一、观察者模式（observer）概要：观察者模式：定义了对象间一种一对多的依赖关系，当目标对象 Subject 的状态发生改变时，所有依赖它的对象 Observer 都会得到通知。这种模式的实质就是我们可以对某个对象的状态进行观察，并且在发生改变时得到通知（以进一步做出相应的行为）。这种模式在平常日用中很常见，比如我们监听 div 的 click 事件，其本质就是观察者模式。function(e) {...}) ```，用文字描述：观察 div 对象，当它被点击了(发生变化)，执行匿名函数(接受通知，然后做出相应行为)。##### 模式特征以及角色： 1、一个目标者对象 Subject，拥有方法：添加 / 删除 / 通知 Observer； 2、多个观察者对象 Observer，拥有方法：接收 Subject 状态变更通知并处理； 3、目标对象 Subject 状态变更时，通知所有 Observer。Subject 可以添加一系列 Observer， Subject 负责维护与这些 Observer 之间的联系，“你对我有兴趣，我更新就会通知你”。 **Subject - 被观察者，发布者;** **Observer - 观察者，订阅者；**### 示例： 为加深理解，以具体实例来看看：现有三个报社，报社一、二、三；有两个订报人，订阅者1，订阅者2。此处，报社就是被观察者、订阅人就是观察者。***被观察者： 主要功能是维护订阅自己的人以及分发消息***```javascriptvar Publish = function(name) { this.name = name; this.subscribers = []; // 数组中存放所有的订阅者，本例中是所代表的观察者的行为} // 分发，发布消息Publish.prototype.deliver = function (news) { var publish = this; // 各报社实例 // 通知所有的订阅者 this.subscribers.forEach(item =&gt; { item(news, publish); // 每个订阅者都收到了 news, 并且还知道是哪家报社发布的 }) return this; // 方便链式调用}观察者： 主要功能是(主动)订阅或取消订阅报社// 订阅Function.prototype.subscribe = function(publish) { var sub = this; // 当前订阅者这个人 // 1. publish.subscribers 中，名字可能重复 // 2. publish.subscribers 数组里面已有的人，不能再次订阅 var alreadyExists = publish.subscribers.some(function(item) { return item === sub; }) // 如果出版社名单中没有这个人，则加入进去 if (!alreadyExists) publish.subscribers.push(sub); return this; // 方便链式调用} // 取消订阅Function.prototype.unsubscribe = function(publish) { var sub = this; // filter (过滤函数:循环便利数组的每一个元素，执行一个函数如果不匹配，则删除该元素) publish.subscribers = publish.subscribers.filter(function(item){ return item !== sub ; }); return this; // 方便链式调用}以上所用的准备工作都已经做完了，接下来具体将具体的demo：// 实例化发布者对象(报社)var pub1 = new Publish('报社一');var pub2 = new Publish('报社二');var pub3 = new Publish('报社三'); // 定义观察者，当报社有了新的消息后，观察者会收到通知// 本例中以观察者的行为代替观察者对象，模拟 addEventListenervar sub1 = function (news, pub) { console.log(arguments); document.getElementById('sub1').innerHTML += pub.name + news + '\\n';} var sub2 = function (news, pub) { console.log(arguments); document.getElementById('sub2').innerHTML += pub.name + news + '\\n';} // 执行订阅方法，这一步是观察者主动sub1.subscribe(pub1).subscribe(pub2);sub2.subscribe(pub1).subscribe(pub2).subscribe(pub3); --------------------- 分割线 ---------------------var p1 = document.getElementById('pub1'); // domvar p2 = document.getElementById('pub2'); // domvar p3 = document.getElementById('pub3'); // dom // 事件绑定, 触发 报社 的消息分发p1.onclick = function() { pub1.deliver(document.getElementById('text1').value, pub1);} p2.onclick = function() { pub2.deliver(document.getElementById('text2').value, pub2);} p3.onclick = function() { pub3.deliver(document.getElementById('text3').value, pub3);}姿势分解：1.分割线之上是报社、订阅者的实例化，以及订阅者订阅报社，如同我们在平常代码中自定义 click 事件一样；2.分割线之下则是普通的添加 click 事件，这里面需要注意的是我们利用自己实现的 deliver 函数完成消息分发(通知)功能；3.点击“报社一”，两个订阅者都收到了通知，执行对应的行为，点击”报社三“，因为只有订阅者2 订阅了这家报社，故只有订阅者2 收到消息并完成行为；ES6实现// 目标者class Subject { constructor() { this. observers = []; // 观察者列表 } // 添加订阅者 add(observer) { this.observers.push(observer); } // 删除... remove(observer) { let idx = this.observers.findIndex(item =&gt; item === observer); idx &gt; -1 &amp;&amp; this.observers.splice(idx, 1); } // 通知 notify() { for(let o of this.observers) { o.update(); } }} // 观察者class Observer { constructor(name) { this.name = name; } // 目标对象更新时触发的回调，即收到更新通知后的回调 update() { console.log(`目标者通知我更新了，我是：${this.name}`); }} // 实例化目标者let subject = new Subject(); // 实例化两个观察者let obs1 = new Observer('前端');let obs2 = new Observer('后端'); // 向目标者添加观察者subject.add(obs1);subject.add(obs2); subject.notify();优缺点：优点明显：降低耦合，两者都专注于自身功能；缺点也很明显：所有观察者都能收到通知，无法过滤筛选；二、发布订阅模式（Publisher &amp;&amp; Subscriber）概要：发布订阅模式：基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，被激活事件的对象 Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。发布订阅模式与观察者模式的不同，“第三者” （事件中心）出现。目标对象并不直接通知观察者，而是通过事件中心来派发通知。代码实现// 控制中心let pubSub = { list: {}, // 订阅 subscribe: function(key, fn) { if (!this.list[key]) this.list[key] = []; this.list[key].push(fn); }, //取消订阅 unsubscribe: function(key, fn) { let fnList = this.list[key]; if (!fnList) return false; if (!fn) { // 不传入指定的方法，清空所用 key 下的订阅 fnList &amp;&amp; (fnList.length = 0); } else { fnList.forEach((item, index) =&gt; { item === fn &amp;&amp; fnList.splice(index, 1); }); } }, // 发布 publish: function(key, ...args) { for (let fn of this.list[key]) fn.call(this, ...args); }} // 订阅pubSub.subscribe('onwork', time =&gt; { console.log(`上班了：${time}`);})pubSub.subscribe('offwork', time =&gt; { console.log(`下班了：${time}`);})pubSub.subscribe('launch', time =&gt; { console.log(`吃饭了：${time}`);}) pubSub.subscribe('onwork', work =&gt; { console.log(`上班了：${work}`);}) // 发布pubSub.publish('offwork', '18:00:00');pubSub.publish('launch', '12:00:00'); // 取消订阅pubSub.unsubscribe('onwork');其实，严格来讲 DOM 的事件监听是“发布订阅模式”：let loginBtn = document.getElementById('#loginBtn'); // 监听回调函数（指定事件）function notifyClick() { console.log('我被点击了');} // 添加事件监听loginBtn.addEventListener('click', notifyClick);// 触发点击, 事件中心派发指定事件loginBtn.click(); // 取消事件监听loginBtn.removeEventListener('click', notifyClick);优缺点：优点：解耦更好，细粒度更容易掌控；缺点：不易阅读，额外对象创建，消耗时间和内存（很多设计模式的通病）；三、两种模式的关联和区别发布订阅模式更灵活，是进阶版的观察者模式，指定对应分发。1、观察者模式维护单一事件对应多个依赖该事件的对象关系；2、发布订阅维护多个事件（主题）及依赖各事件（主题）的对象之间的关系；3、观察者模式是目标对象直接触发通知（全部通知），观察对象被迫接收通知。发布订阅模式多了个中间层（事件中心），由其去管理通知广播（只通知订阅对应事件的对象）；4、观察者模式对象间依赖关系较强，发布订阅模式中对象之间实现真正的解耦。","link":"/allArticles/观察者模式与发布订阅模式/"},{"title":"JavaScript手写代码无敌秘籍","text":"中高级前端面试之手写代码实现一个new操作符实现一个JSON.stringify实现一个JSON.parse实现一个call或 apply实现一个Function.bind实现一个继承实现一个JS函数柯里化手写一个Promise(中高级必考)手写防抖(Debouncing)和节流(Throttling)手写一个JS深拷贝实现一个instanceOf1. 实现一个 new 操作符new 操作符做了这些事：它创建了一个全新的对象。它会被执行 [[Prototype]]（也就是 __proto__）链接。它使 this 指向新创建的对象。通过 new 创建的每个对象将最终被 [[Prototype]] 链接到这个函数的 prototype 对象上。如果函数没有返回对象类型 Object (包含 Functoin, Array, Date, RegExg, Error )，那么 new 表达式中的函数调用将返回该对象引用。function New(func) { var res = {}; if (func.prototype !== null) { res.__proto__ = func.prototype; } var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === \"object\" || typeof ret === \"function\") &amp;&amp; ret !== null) { return ret; } return res;}var obj = New(A, 1, 2);// equals tovar obj = new A(1, 2);2. 实现一个 JSON.stringifyJSON.stringify(value[, replacer [, space]])Boolean | Number| String 类型会自动转换成对应的原始值。undefined、任意函数以及 symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。不可枚举的属性会被忽略如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。function jsonStringify(obj) { let type = typeof obj; if (type !== \"object\") { if (/string|undefined|function/.test(type)) { obj = '\"' + obj + '\"'; } return String(obj); } else { let json = [] let arr = Array.isArray(obj) for (let k in obj) { let v = obj[k]; let type = typeof v; if (/string|undefined|function/.test(type)) { v = '\"' + v + '\"'; } else if (type === \"object\") { v = jsonStringify(v); } json.push((arr ? \"\" : '\"' + k + '\":') + String(v)); } return (arr ? \"[\" : \"{\") + String(json) + (arr ? \"]\" : \"}\") }}jsonStringify({x : 5}) // \"{\"x\":5}\"jsonStringify([1, \"false\", false]) // \"[1,\"false\",false]\"jsonStringify({b: undefined}) // \"{\"b\":\"undefined\"}\"3. 实现一个 JSON.parseJSON.parse(text[, reviver])用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。3.1 第一种：直接调用 evalfunction jsonParse(opt) { return eval('(' + opt + ')');}jsonParse(jsonStringify({x : 5}))// Object { x: 5}jsonParse(jsonStringify([1, \"false\", false]))// [1, \"false\", falsr]jsonParse(jsonStringify({b: undefined}))// Object { b: \"undefined\"}避免在不必要的情况下使用 eval，eval() 是一个危险的函数， 他执行的代码拥有着执行者的权利。如果你用 eval()运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。它会执行JS代码，有XSS漏洞。如果你只想记这个方法，就得对参数json做校验。var rx_one = /^[\\],:{}\\s]*$/;var rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;var rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;if ( rx_one.test( json .replace(rx_two, \"@\") .replace(rx_three, \"]\") .replace(rx_four, \"\") )) { var obj = eval(\"(\" +json + \")\");}3.2 第二种：Function核心：Function 与 eval 有相同的字符串参数特性。var func = new Function(arg1, arg2, ..., functionBody);在转换JSON的实际应用中，只需要这么做。var jsonStr = '{ \"age\": 20, \"name\": \"jack\" }'var json = (new Function('return ' + jsonStr))();eval 与 Function 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。4. 实现一个 call 或 applycall 语法：fun.call(thisArg, arg1, arg2, …)，调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。apply 语法：func.apply(thisArg, [argsArray])，调用一个函数，以及作为一个数组（或类似数组对象）提供的参数。4.1 Function.call 按套路实现call核心：将函数设为对象的属性执行&amp;删除这个函数指定this到函数并传入给定参数执行函数如果不传入参数，默认指向为 window4.1.1 简单版var foo = { value: 1, bar: function() { console.log(this.value) }}foo.bar() // 14.1.2 完善版Function.prototype.call2 = function(content = window) { content.fn = this; let args = [...arguments].slice(1); let result = content.fn(...args); delete content.fn; return result;}let foo = { value: 1}function bar(name, age) { console.log(name) console.log(age) console.log(this.value);}bar.call2(foo, 'black', '18') // black 18 14.2 Function.apply 的模拟实现apply() 的实现和 call() 类似，只是参数形式不同。Function.prototype.apply2 = function(context = window) { context.fn = this let result; // 判断是否有第二个参数 if(arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result}5. 实现一个 Function.bind()bind() 方法:会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )此外，bind 实现需要考虑实例化后对原型链的影响。Function.prototype.bind2 = function(content) { if(typeof this != \"function\") { throw Error(\"not a function\") } // 若没问参数类型则从这开始写 let fn = this; let args = [...arguments].slice(1); let resFn = function() { return fn.apply(this instanceof resFn ? this : content,args.concat(...arguments) ) } function tmp() {} tmp.prototype = this.prototype; resFn.prototype = new tmp(); return resFn;}6. 实现一个继承寄生组合式继承一般只建议写这种，因为其它方式的继承会在一次实例中调用两次父类的构造函数或有其它缺点。核心实现是：用一个 *F 空的构造函数去取代执行了 Parent* 这个构造函数。function Parent(name) { this.name = name;}Parent.prototype.sayName = function() { console.log('parent name:', this.name);}function Child(name, parentName) { Parent.call(this, parentName); this.name = name; }function create(proto) { function F(){} F.prototype = proto; return new F();}Child.prototype = create(Parent.prototype);Child.prototype.sayName = function() { console.log('child name:', this.name);}Child.prototype.constructor = Child;var parent = new Parent('father');parent.sayName(); // parent name: fathervar child = new Child('son', 'father');7. 实现一个JS函数柯里化什么是柯里化？在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。7.1 通用版function curry(fn, args) { var length = fn.length; var args = args || []; return function(){ newArgs = args.concat(Array.prototype.slice.call(arguments)); if (newArgs.length &lt; length) { return curry.call(this,fn,newArgs); }else{ return fn.apply(this,newArgs); } }}function multiFn(a, b, c) { return a * b * c;}var multi = curry(multiFn);multi(2)(3)(4);multi(2,3,4);multi(2)(3,4);multi(2,3)(4);7.2 ES6写法const curry = (fn, arr = []) =&gt; (...args) =&gt; ( arg =&gt; arg.length === fn.length ? fn(...arg) : curry(fn, arg))([...arr, ...args])let curryTest=curry((a,b,c,d)=&gt;a+b+c+d)curryTest(1,2,3)(4) //返回10curryTest(1,2)(4)(3) //返回10curryTest(1,2)(3,4) //返回108. 手写一个 Promise (中高级必考)我们来过一遍 Promise/A+ 规范：三种状态 pending| fulfilled(resolved) | rejected当处于 pending 状态的时候，可以转移到 fulfilled(resolved)或者 rejected状态当处于 fulfilled(resolved) 状态或者 rejected 状态的时候，就不可变。必须有一个 then 异步执行方法，then 接受两个参数且必须返回一个 promise.// onFulfilled 用来接收promise成功的值// onRejected 用来接收promise失败的原因var promise1=promise.then(onFulfilled, onRejected);8.1 Promise 的流程图分析来回顾下 Promise 用法：var promise = new Promise((resolve,reject) =&gt; { if (操作成功) { resolve(value) } else { reject(error) }})promise.then(function (value) { // success},function (value) { // failure})8.2 面试版function myPromise(constructor){ let self=this; self.status=\"pending\" //定义状态改变前的初始状态 self.value=undefined;//定义状态为resolved的时候的状态 self.reason=undefined;//定义状态为rejected的时候的状态 function resolve(value){ //两个===\"pending\"，保证了状态的改变是不可逆的 if(self.status===\"pending\"){ self.value=value; self.status=\"resolved\"; } } function reject(reason){ //两个===\"pending\"，保证了状态的改变是不可逆的 if(self.status===\"pending\"){ self.reason=reason; self.status=\"rejected\"; } } //捕获构造异常 try{ constructor(resolve,reject); }catch(e){ reject(e); }}同时，需要在 myPromise 的原型上定义链式调用的 then 方法：myPromise.prototype.then=function(onFullfilled,onRejected){ let self=this; switch(self.status){ case \"resolved\": onFullfilled(self.value); break; case \"rejected\": onRejected(self.reason); break; default: }}测试一下：var p=new myPromise(function(resolve,reject){resolve(1)});p.then(function(x){console.log(x)})//输出18.3 大厂专供版直接贴代码const PENDING = \"pending\";const FULFILLED = \"fulfilled\";const REJECTED = \"rejected\";function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if(value instanceof Promise) { return value.then(resolve, reject); } // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() =&gt; { // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) { // 只能由pending状态 =&gt; fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() =&gt; { // 调用reject 回调对应onRejected函数 if (that.status === PENDING) { // 只能由pending状态 =&gt; rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) =&gt; { // throw new Error('error in excutor') // }) try { excutor(resolve, reject); } catch (e) { reject(e); }}Promise.prototype.then = function(onFulfilled, onRejected) { const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === \"function\" ? onRejected : reason =&gt; { throw reason; }; if (that.status === FULFILLED) { // 成功态 return newPromise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { try{ let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 } catch(e) { reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); } }); }) } if (that.status === REJECTED) { // 失败态 return newPromise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { try { let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } if (that.status === PENDING) { // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) =&gt; { that.onFulfilledCallbacks.push((value) =&gt; { try { let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); that.onRejectedCallbacks.push((reason) =&gt; { try { let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); }};9. 手写防抖(Debouncing)和节流(Throttling)scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），有两种常用的解决方法，防抖和节流。9.1 防抖( Debouncing )实现典型例子：限制 鼠标连击 触发。一个比较好的解释是：当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。// 防抖动函数function debounce(fn,wait=50,immediate) { let timer; return function() { if(immediate) { fn.apply(this,arguments) } if(timer) clearTimeout(timer) timer = setTimeout(()=&gt; { fn.apply(this,arguments) },wait) }}结合实例：滚动防抖// 简单的防抖动函数// 实际想绑定在 scroll 事件上的 handlerfunction realFunc(){ console.log(\"Success\");}// 采用了防抖动window.addEventListener('scroll',debounce(realFunc,500));// 没采用防抖动window.addEventListener('scroll',realFunc);9.2 节流( Throttling )实现可以理解为事件在一个管道中传输，加上这个节流阀以后，事件的流速就会减慢。实际上这个函数的作用就是如此，它可以将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次.简单的节流函数:function throttle(fn, wait) { let prev = new Date(); return function() { const args = arguments; const now = new Date(); if (now - prev &gt; wait) { fn.apply(this, args); prev = new Date(); } }}9.3 结合实践通过第三个参数来切换模式。const throttle = function (fn, delay, isDebounce) { let timer; let lastCall = 0; return function (...args) { if (isDebounce) { if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; { fn(...args); }, delay); } else { const now = new Date().getTime(); if (now - lastCall &lt; delay) return; lastCall = now; fn(...args); } }}10. 手写一个 JS 深拷贝10.1 最简版var newObj = JSON.parse( JSON.stringify( someObj ));10.2 面试版function deepCopy(obj){ //判断是否是简单数据类型， if(typeof obj == \"object\"){ //复杂数据类型 var result = obj.constructor == Array ? [] : {}; for(let i in obj){ result[i] = typeof obj[i] == \"object\" ? deepCopy(obj[i]) : obj[i]; } }else { //简单数据类型 直接 == 赋值 var result = obj; } return result;}11. 实现一个 instanceOffunction instanceOf(left,right) { let proto = left.__proto__; let prototype = right.prototype while(true) { if(proto === null) return false if(proto === prototype) return true proto = proto.__proto__; }}","link":"/allArticles/JavaScript手写代码无敌秘籍/"}],"tags":[{"name":"localStorage","slug":"localStorage","link":"/tags/localStorage/"},{"name":"sessionStorage","slug":"sessionStorage","link":"/tags/sessionStorage/"},{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"JSON.stringify","slug":"JSON-stringify","link":"/tags/JSON-stringify/"},{"name":"JSON.parse","slug":"JSON-parse","link":"/tags/JSON-parse/"},{"name":"call/apply/bind","slug":"call-apply-bind","link":"/tags/call-apply-bind/"},{"name":"柯里化","slug":"柯里化","link":"/tags/柯里化/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"节流/防抖","slug":"节流-防抖","link":"/tags/节流-防抖/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/深拷贝/"},{"name":"继承","slug":"继承","link":"/tags/继承/"},{"name":"instanceOf","slug":"instanceOf","link":"/tags/instanceOf/"}],"categories":[{"name":"javaScript","slug":"javaScript","link":"/categories/javaScript/"},{"name":"localStorage","slug":"javaScript/localStorage","link":"/categories/javaScript/localStorage/"},{"name":"面试","slug":"javaScript/面试","link":"/categories/javaScript/面试/"},{"name":"promise","slug":"javaScript/promise","link":"/categories/javaScript/promise/"},{"name":"sessionStorage","slug":"javaScript/localStorage/sessionStorage","link":"/categories/javaScript/localStorage/sessionStorage/"},{"name":"算法","slug":"javaScript/面试/算法","link":"/categories/javaScript/面试/算法/"},{"name":"async","slug":"javaScript/promise/async","link":"/categories/javaScript/promise/async/"},{"name":"await","slug":"javaScript/promise/async/await","link":"/categories/javaScript/promise/async/await/"}]}