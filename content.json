{"pages":[{"title":"关于我！","text":"大家好，我是一名前端工程师，每天会根据时间更新一下自己的博客，内容是自己所学亦或是从别处理解之个人见解，前端道路漫长，有趣之中也会有很多烦躁，所以也会更新一下夜读美文，或者经典语句，夜深人静之时，解解闷儿。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"link","text":"","link":"/link/index.html"}],"posts":[{"title":"JavaScript手写代码无敌秘籍","text":"中高级前端面试之手写代码 实现一个new操作符 实现一个JSON.stringify 实现一个JSON.parse 实现一个call或 apply 实现一个Function.bind 实现一个继承 实现一个JS函数柯里化 手写一个Promise(中高级必考) 手写防抖(Debouncing)和节流(Throttling) 手写一个JS深拷贝 实现一个instanceOf 1. 实现一个 new 操作符 new 操作符做了这些事： 它创建了一个全新的对象。 它会被执行 [[ Prototype ]]（也就是 __proto__）链接。 它使 this 指向新创建的对象。 通过 new 创建的每个对象将最终被 [[ Prototype ]] 链接到这个函数的 prototype 对象上。 如果函数没有返回对象类型 Object (包含 Functoin, Array, Date, RegExg, Error )，那么 new 表达式中的函数调用将返回该对象引用。 function New(func) { var res = {}; if (func.prototype !== null) { res.__proto__ = func.prototype; } var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === \"object\" || typeof ret === \"function\") &amp;&amp; ret !== null) { return ret; } return res;}var obj = New(A, 1, 2);// equals tovar obj = new A(1, 2); 2. 实现一个 JSON.stringify JSON.stringify(value[, replacer [, space]]) Boolean | Number| String 类型会自动转换成对应的原始值。 undefined、任意函数以及 symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。 不可枚举的属性会被忽略 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。 function jsonStringify(obj) { let type = typeof obj; if (type !== \"object\") { if (/string|undefined|function/.test(type)) { obj = '\"' + obj + '\"'; } return String(obj); } else { let json = [] let arr = Array.isArray(obj) for (let k in obj) { let v = obj[k]; let type = typeof v; if (/string|undefined|function/.test(type)) { v = '\"' + v + '\"'; } else if (type === \"object\") { v = jsonStringify(v); } json.push((arr ? \"\" : '\"' + k + '\":') + String(v)); } return (arr ? \"[\" : \"{\") + String(json) + (arr ? \"]\" : \"}\") }}jsonStringify({x : 5}) // \"{\"x\":5}\"jsonStringify([1, \"false\", false]) // \"[1,\"false\",false]\"jsonStringify({b: undefined}) // \"{\"b\":\"undefined\"}\" 3. 实现一个 JSON.parse JSON.parse(text[, reviver]) 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。 3.1 第一种：直接调用 evalfunction jsonParse(opt) { return eval('(' + opt + ')');}jsonParse(jsonStringify({x : 5}))// Object { x: 5}jsonParse(jsonStringify([1, \"false\", false]))// [1, \"false\", falsr]jsonParse(jsonStringify({b: undefined}))// Object { b: \"undefined\"} 避免在不必要的情况下使用 eval，eval() 是一个危险的函数， 他执行的代码拥有着执行者的权利。如果你用 eval()运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。 它会执行JS代码，有XSS漏洞。 如果你只想记这个方法，就得对参数json做校验。var rx_one = /^[\\],:{}\\s]*$/;var rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;var rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;if ( rx_one.test( json .replace(rx_two, \"@\") .replace(rx_three, \"]\") .replace(rx_four, \"\") )) { var obj = eval(\"(\" +json + \")\");} 3.2 第二种：Function核心：Function 与 eval 有相同的字符串参数特性。 var func = new Function(arg1, arg2, ..., functionBody); 在转换JSON的实际应用中，只需要这么做。 var jsonStr = '{ \"age\": 20, \"name\": \"jack\" }'var json = (new Function('return ' + jsonStr))(); eval 与 Function 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。 4. 实现一个 call 或 apply call 语法： fun.call(thisArg, arg1, arg2, …)，调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 apply 语法： func.apply(thisArg, [argsArray])，调用一个函数，以及作为一个数组（或类似数组对象）提供的参数。 4.1 Function.call 按套路实现call核心： 将函数设为对象的属性 执行&amp;删除这个函数 指定this到函数并传入给定参数执行函数 如果不传入参数，默认指向为 window 4.1.1 简单版var foo = { value: 1, bar: function() { console.log(this.value) }}foo.bar() // 1 4.1.2 完善版Function.prototype.call2 = function(content = window) { content.fn = this; let args = [...arguments].slice(1); let result = content.fn(...args); delete content.fn; return result;}let foo = { value: 1}function bar(name, age) { console.log(name) console.log(age) console.log(this.value);}bar.call2(foo, 'black', '18') // black 18 1 4.2 Function.apply 的模拟实现apply() 的实现和 call() 类似，只是参数形式不同。Function.prototype.apply2 = function(context = window) { context.fn = this let result; // 判断是否有第二个参数 if(arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result} 5. 实现一个 Function.bind() bind() 方法: 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 此外，bind 实现需要考虑实例化后对原型链的影响。 Function.prototype.bind2 = function(content) { if(typeof this != \"function\") { throw Error(\"not a function\") } // 若没问参数类型则从这开始写 let fn = this; let args = [...arguments].slice(1); let resFn = function() { return fn.apply(this instanceof resFn ? this : content,args.concat(...arguments) ) } function tmp() {} tmp.prototype = this.prototype; resFn.prototype = new tmp(); return resFn;} 6. 实现一个继承 寄生组合式继承 一般只建议写这种，因为其它方式的继承会在一次实例中调用两次父类的构造函数或有其它缺点。 核心实现是：用一个 *F 空的构造函数去取代执行了 Parent* 这个构造函数。 function Parent(name) { this.name = name;}Parent.prototype.sayName = function() { console.log('parent name:', this.name);}function Child(name, parentName) { Parent.call(this, parentName); this.name = name; }function create(proto) { function F(){} F.prototype = proto; return new F();}Child.prototype = create(Parent.prototype);Child.prototype.sayName = function() { console.log('child name:', this.name);}Child.prototype.constructor = Child;var parent = new Parent('father');parent.sayName(); // parent name: fathervar child = new Child('son', 'father'); 7. 实现一个JS函数柯里化 什么是柯里化？ 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。 函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。 7.1 通用版function curry(fn, args) { var length = fn.length; var args = args || []; return function(){ newArgs = args.concat(Array.prototype.slice.call(arguments)); if (newArgs.length &lt; length) { return curry.call(this,fn,newArgs); }else{ return fn.apply(this,newArgs); } }}function multiFn(a, b, c) { return a * b * c;}var multi = curry(multiFn);multi(2)(3)(4);multi(2,3,4);multi(2)(3,4);multi(2,3)(4); 7.2 ES6写法const curry = (fn, arr = []) =&gt; (...args) =&gt; ( arg =&gt; arg.length === fn.length ? fn(...arg) : curry(fn, arg))([...arr, ...args])let curryTest=curry((a,b,c,d)=&gt;a+b+c+d)curryTest(1,2,3)(4) //返回10curryTest(1,2)(4)(3) //返回10curryTest(1,2)(3,4) //返回10 我们来过一遍 Promise/A+ 规范： 三种状态 pending| fulfilled(resolved) | rejected 当处于 pending 状态的时候，可以转移到 fulfilled(resolved)或者 rejected状态 当处于 fulfilled(resolved) 状态或者 rejected 状态的时候，就不可变。 必须有一个 then 异步执行方法，then 接受两个参数且必须返回一个 promise. // onFulfilled 用来接收promise成功的值// onRejected 用来接收promise失败的原因promise1=promise.then(onFulfilled, onRejected); 8.1 Promise 的流程图分析 来回顾下 Promise 用法： var promise = new Promise((resolve,reject) =&gt; { if (操作成功) { resolve(value) } else { reject(error) }})promise.then(function (value) { // success},function (value) { // failure}) 8.2 面试版function myPromise(constructor){ let self=this; self.status=\"pending\" //定义状态改变前的初始状态 self.value=undefined;//定义状态为resolved的时候的状态 self.reason=undefined;//定义状态为rejected的时候的状态 function resolve(value){ //两个===\"pending\"，保证了状态的改变是不可逆的 if(self.status===\"pending\"){ self.value=value; self.status=\"resolved\"; } } function reject(reason){ //两个===\"pending\"，保证了状态的改变是不可逆的 if(self.status===\"pending\"){ self.reason=reason; self.status=\"rejected\"; } } //捕获构造异常 try{ constructor(resolve,reject); }catch(e){ reject(e); }} 同时，需要在 myPromise 的原型上定义链式调用的 then 方法： myPromise.prototype.then=function(onFullfilled,onRejected){ let self=this; switch(self.status){ case \"resolved\": onFullfilled(self.value); break; case \"rejected\": onRejected(self.reason); break; default: }} 测试一下： var p=new myPromise(function(resolve,reject){resolve(1)});p.then(function(x){console.log(x)})//输出1 8.3 大厂专供版直接贴代码 const PENDING = \"pending\";const FULFILLED = \"fulfilled\";const REJECTED = \"rejected\";function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if(value instanceof Promise) { return value.then(resolve, reject); } // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() =&gt; { // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) { // 只能由pending状态 =&gt; fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() =&gt; { // 调用reject 回调对应onRejected函数 if (that.status === PENDING) { // 只能由pending状态 =&gt; rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) =&gt; { // throw new Error('error in excutor') // }) try { excutor(resolve, reject); } catch (e) { reject(e); }}Promise.prototype.then = function(onFulfilled, onRejected) { const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === \"function\" ? onRejected : reason =&gt; { throw reason; }; if (that.status === FULFILLED) { // 成功态 return newPromise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { try{ let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 } catch(e) { reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); } }); }) } if (that.status === REJECTED) { // 失败态 return newPromise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { try { let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); } if (that.status === PENDING) { // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) =&gt; { that.onFulfilledCallbacks.push((value) =&gt; { try { let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); that.onRejectedCallbacks.push((reason) =&gt; { try { let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); } catch(e) { reject(e); } }); }); }}; 9. 手写防抖(Debouncing)和节流(Throttling) scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），有两种常用的解决方法，防抖和节流。 9.1 防抖( Debouncing )实现典型例子：限制 鼠标连击 触发。 一个比较好的解释是： 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。 // 防抖动函数function debounce(fn,wait=50,immediate) { let timer; return function() { if(immediate) { fn.apply(this,arguments) } if(timer) clearTimeout(timer) timer = setTimeout(()=&gt; { fn.apply(this,arguments) },wait) }} 结合实例：滚动防抖 // 简单的防抖动函数// 实际想绑定在 scroll 事件上的 handlerfunction realFunc(){ console.log(\"Success\");}// 采用了防抖动window.addEventListener('scroll',debounce(realFunc,500));// 没采用防抖动window.addEventListener('scroll',realFunc); 9.2 节流( Throttling )实现 可以理解为事件在一个管道中传输，加上这个节流阀以后，事件的流速就会减慢。实际上这个函数的作用就是如此，它可以将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次. 简单的节流函数: function throttle(fn, wait) { let prev = new Date(); return function() { const args = arguments; const now = new Date(); if (now - prev &gt; wait) { fn.apply(this, args); prev = new Date(); } }} 9.3 结合实践通过第三个参数来切换模式。 const throttle = function (fn, delay, isDebounce) { let timer; let lastCall = 0; return function (...args) { if (isDebounce) { if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; { fn(...args); }, delay); } else { const now = new Date().getTime(); if (now - lastCall &lt; delay) return; lastCall = now; fn(...args); } }} 10. 手写一个JS深拷贝10.1 最简版var newObj = JSON.parse( JSON.stringify( someObj )); 10.2 面试版function deepCopy(obj){ //判断是否是简单数据类型， if(typeof obj == \"object\"){ //复杂数据类型 var result = obj.constructor == Array ? [] : {}; for(let i in obj){ result[i] = typeof obj[i] == \"object\" ? deepCopy(obj[i]) : obj[i]; } }else { //简单数据类型 直接 == 赋值 var result = obj; } return result;}","link":"/JavaScript手写代码无敌秘籍/"},{"title":"心越简单，人越幸福","text":"幸福有时真的很简单！曾经总以为，要想获得幸福，需要许多外在物质的支撑。 可随着年龄的增长，你逐渐会发现，幸福更多时刻，只是一种内心的感受，与金钱名利无关。 当你拖着疲惫的身躯，加班回到家，发现城市的万千灯火里，能有一盏灯为你亮时。 当你生病住院时，能有个人陪在你身旁，为你熬药煮粥，对你不离不弃时。 当你感到快乐时，你可以找到一个人，分享你的喜悦。当你难过时，也有一个人，可以给你一个肩膀做依靠时。 幸福并不遥远，它近在咫尺。幸福也并不陌生，它就藏在我们熟悉的生活中，关键需要你用心地去发现和感知。 人人都有拥有幸福的权利，但如果你要求得太多，苛责得太多，抱怨得太多，就不容易找到它。 其实，你若能从琐碎的日常中，从柴米油盐的平凡日子里，提炼出美好的能力，也可以将日子开出绚烂的花儿。 你是否有这样的感觉，有时会感到很孤独。因为聊得来的人越来越少，可以交心的人也越来越少。 无论你做任何决定，有什么选择，周围的人，仿佛都不理解你，甚至他们还总是质疑你。 有时，你还会为此，有深深的挫败感。 但你总要知道，人这辈子，无法做到让所有人都满意，也不必让所有人都懂你，如果强求，只会让自己过得越来越疲惫。 一个前同事给我打来电话，诉说她这段时间，在工作中遇到的烦心事。 她不无委屈地说，为什么我做了一件好事，但员工都不理解我，他们只看得见眼前的利益，却看不见长远的打算。 我安慰她说，只要你心是善的，你的决定，也经得起时间的考验，那么无论他们是否明白，你都可以做到问心无愧。 她听后说到，现在我的心情释然了很多，至少还有你理解我。 当我们在做决定时，总被旁人的眼光和评价所左右，甚至我们也总想得到更多人的支持和认可。 后来才明白，在这个世上，懂你的人，不必你解释。不懂你的人，解释也无用。 人生有时，并不需要有那么多人懂你，你自己懂你自己，以及有那么一两个知己好友懂你，就足矣。 一个读者跟我说，她有一次帮客户去找房子，跟着中介，在炎炎夏日的街头跑了一天，不仅又累又热，双脚还磨起了泡。 但她当时最大的感受，反而不是抱怨身体上吃的苦，而是突然感觉到自己平时真的太幸福了。 曾经她总对自己的工作不满意，比如任务重，压力大，考核严。那时，她总拿自己，跟那些高薪高职的人相比，于是越比心里就越不平衡。 可她现在才知道，原来在这个世界上，还有比她更辛苦，更忙碌，更劳碌的人，并没有她那么好的工作条件，可以不用日晒雨淋，可以有节庆双休，也拥有更多时间上的自由。 因为她总看到，别人有着比她更优越的条件，所以会心生嫉妒，但她却没有看到别人付出的比她多。 同时，她也并不知道，只要你尽自己所能，干好自己应该干的，哪怕是一件看起来微不足道的小事，也算是成功。 其实，大多数人的不快乐，往往来源于爱比较和不知足。 凡事你若争强好胜，只会让自己越来越痛苦。 但若你懂得，怀着一颗感恩的心，去珍惜你的工作，去善待你的生活，那么你就会多一分坦然和快乐。 虽然每个人对幸福的定义不一样，但幸福的感受，往往是相似的，想要获得幸福的心，也是相同的。 也许我们会因为各种条件，机遇和环境的不同，而过上截然不同的人生，但只要我们学会给心灵减负，学会控制欲望，学会不去盲目攀比，就会让自己活得更加轻松愉快。 其实，幸福有时真的很简单。 比如你拥有一份稳定的工作，虽然它需要你忙一点，累一点，辛苦一点，但它可以让你去实现自己的人生价值，也可以让你有底气和资本去挣钱养家。 比如你拥有一个和睦的家庭，虽然父母观念老一点，孩子调皮一点，另一半的脾气大一点，但家人闲坐，灯火可亲的感觉，是那么难能可贵。 比如你拥有几个可以互诉衷肠的朋友，虽然他们有时并不能给你及时的安慰和陪伴，又或者你们之间有些小矛盾，但能有哪怕一个交心的知己，也是人生一大幸事。 但如果你将幸福看得太复杂，你的内心太浑浊，你用恶意去揣测你所遇到的人和事，那么你就会感到十分压抑和痛苦。 其实当一个人，少一些世故，多一些单纯；少一些套路，多一些真诚；少一些浮躁，多一些宁静；就会活得更加澄明、坦率和自由。","link":"/夜读20191004/"},{"title":"一个人越过越好的6个迹象","text":"活成自己喜欢的样子！看到一句很有道理的话：一个人最好的状态莫过于，眼里写满了故事，脸上却不见风霜，不羡慕谁，不嘲笑谁，也不依赖谁。只是悄悄地努力，吞下委屈，喂大格局，活成自己喜欢的样子。 深以为然。 生活不需要太多事参与，故事不需要讲给太多人听。一个人安安静静努力，慢慢靠近自己想要的生活，就足矣。 生活越来越舒服，人生越过越成熟，自己越活越坦然的六个迹象，来看看，你中了几条？ 第一条，明白赚钱的重要性，但不把攒钱当作唯一目的。 亦舒说：记得积蓄，那样有朝一日失去任何人的欢心，都可以不愁衣食地伤春悲秋，缅怀过去。 的确，你不必特别有钱，但一定不能特别缺钱。钱不是万能的，但手里多一点钱，真的能叫自己少吃些苦。 赚钱和积蓄真的是很重要的事情。 不过，我希望你也要记得，别把攒钱当作唯一目的。 银行卡上的数字不应该成为你全部的安全感来源。 这世界，除了柴米油盐，还有远方的诗和田野。 不要总是低着头朝前走，偶尔停下脚步抬头看看满天的繁星。 想想自己当下最期待的生活是什么样的，不要忘记自己年少时的初心。 就像《流金岁月》中说的：无论做什么，记得为自己而做，那就毫无怨言。 人只活一辈子，不要太苛待自己，在能力范围之内给自己更好的，也是对生命的一种馈赠。 第二条，不害怕接近爱，也不盲目付出爱。 人活在世上，总免不了经历七情六欲，亲情、爱情、友情，点头之交，擦肩陌路…… 相遇和离别，每天都在上演。 以前总想着让认识的人都喜欢自己，想和更多的人成为朋友。 待人友善是修养，独来独往是性格。你不懂我，我不怪你，淡然远之，各自安好。 不害怕与人相处，也不惧于接受谁的好感和爱意。 但绝不会因为年龄或者一些本心之外的东西选择将就一段生活。 明白自己的感情很贵，不是谁都能给，如果不值得，如果没回应，那就算了。 余生很贵，取悦好自己，照顾好值得放在心上的人，不要将就，更别浪费。 第三条，比起无聊的消遣，更愿意独处和读书。 很多快速的东西往往都很短暂，偷走了你当下的时间，却并不能在你心里留下更深刻的印象。 偶尔小幅度的放纵可以让人感到愉悦和放松，但如果把堕落当成一种快乐，时间久了，只会让自己越来越难于开始自律。 没事早点睡，有空多读书，一个人的时候别浮躁，别焦虑；沉下心去磨一磨自己的脾气和性子，在书里见天地，见众生，更见自我。 要让自己成为一块有棱角但不锋芒外露，有骨气但外表温凉柔润的美玉。 你读过的书、走过的路和爱过的人，都会成为你人生路上的指路牌。那些也许你已经忘记了的书里的片段，其实都在指引你前行的方向。它们一定会在未来的某一个时刻，帮助你表现得更出色。 所以，要主动把自己从垃圾快乐中解救出来，独处和读书，往后余生，且行且记。 第四条，懂得自律才是自由的前提，并愿意为之付诸努力。 看过这样一句话：生活中的不如意总比如意多。 而对此的恪守、热情，恰恰也缘于自身的坚韧。时刻提醒自己，要自律，要保持内在的从容与安静。 无论在人生的哪个阶段，都不能放弃成长，没有人能限制你人生的高度，只要你不要让心受限，一切都有可能。 康德说：自律即自由。 先有自律，懂得隐忍和克制，放弃一些不重要的，坚持一些优秀的；而后才能因此获得真正的自由，成为自己想要的样子。 坚持一件能够让自己变好的事的确不容易，打磨自己的过程也总是充满了艰难和迷茫。 但只要你在朝前走，只要你在朝着更优秀的方向拼搏，即使最后失败，也是最难能可贵的经历。 思考、行动、自律、坚持，共勉。 要相信，勇于大步向前走的人，总能够找到属于自己的光亮。 第五条，有些人该放就放。 人生就像一条路，从起点出发，到终点结束，不长不短刚刚好。 但在开始时，我们因过于懵懂而无法抉择，可待到结束时，回望一生却总觉得有诸多悔恨。 其实未来和过去，都不是我们该看重的东西，时光飞逝，只该抓紧今日。 珍惜现在拥有的人和事，感恩如今生命馈赠的一切，得不到的就不要去想它，已经失去的，就赶紧放下吧。 有些事得过且过，有些人该忘就忘。 别因为一时的失意就沉沦放纵，也别把悲伤和难过郁结在心里。 生活本就很苦了，但你可以学着做自己的草莓味儿； 保持健康的身体和积极的心灵，从每一个当下开始，期许新生活。 第六条，先爱自己，而后爱人。 坚持读书，写字，听歌，旅行，上网，摄影，有时唱歌，跳舞，打扫，烹饪，约会，狂欢。” 无论遇见什么，人生都在照常运转，无论离开了谁，生活也不能停滞不前。 不懂先为自己付出的人，就算为别人掏心掏肺，也会被当作理所当然； 不懂先爱自己的人，就算把自己感动得痛哭流涕，也无法真正拥有合适的爱情和生活。 先爱自己，而后爱人。 如此，便能够为了开心而保持微笑，为了幸福而变得坚韧；如此便不会为了一个不值得的人伤神沉沦，不会为了不必要的事大动肝火。 只此一世，取悦自己，真的很重要。 希望你也成为这样的人，眼里长着太阳，笑里全是坦荡。余生漫漫，且行且成长，且行，珍惜。","link":"/夜读20191006/"},{"title":"世界再大，也不如有人等你回家","text":"世界上最美的风景，是回家的路！最近，一则90秒的短片在朋友圈刷屏，让无数人为之动容。 夜晚，灯火阑珊。女主角依然为了工作忙得不可开交。 这样的情形，已经成了现代城市年轻人的一个缩影。 节日到了，母亲希望女儿回家一趟，言外之意还有让她相亲的意思。 但是女主角并不愿意父母干涉自己的事儿，无奈之下只好借口出游躲避回家后的“麻烦”。 当假期如约而至，女主角开始踏上自己的旅程。 旅途上的一个小插曲，无意间触动了她心中的那一份柔软： 高速路服务区，一位技工小哥，在帮她检测车辆的时候，收到了家中的电话。 为了坚守自己的岗位，方便大家的出行，就连节假日他也无法抽身回乡。与此同时，女主角的母亲也再次给她发来关心的短信。 直到这一刻女主角才发现，原来有些近在咫尺的幸福，于另外一些人而言，却是一种奢望。 视频的最后，当女主开始踏上回家旅程的那一刻，我的心中也仿佛有一块石头重重地落下。 原来，这个世界再大，也不如有人等你回家。 上周，我刚到办公室，就发现同事群里一阵骚乱。 原来国庆临近，很多同事都没有抢到火车票，有的撺掇着拼车回家，有的忙着发送抢票链接，一片慌乱。 在外工作多年，这样的场景早就是一种常态，本来我不以为意，但是同事小艾还是引起了我的注意。 小艾是公司来的新人，脾气倔得很，因为毕业后的择业问题与父母产生了一些矛盾，所以来北京这几年，即便步履维艰，她也很少回家。 但是这一次，我却见到了她在同事群连发了三条“求救信息”： “哥哥姐姐们，求加速，抢不到回家的车票啦。” 后面还缀上了一个大哭的表情。 后来，我们吃饭聊天，她说起这一件小事，不仅让她备受感动，恍然大悟，也让我感触颇深。 原来中秋的前一天是小艾的生日，她本以为自己又要孤独地长大一岁。可就在她上一秒还在和父母通电话，说放假不能回家时，公寓的门铃突然响起。 开门的那一刻，她无论如何都不会想到，外面站着的竟然是从千里之外风尘仆仆赶来的父母。 望着他们手里提着那盒她最喜欢吃的水果蛋糕，小艾瞬间泪目。 的确，父母和子女之间必将经历一场又一场的别离，但是彼此的爱不会因为距离而衰减。 他们希望你过得好，盼着你变强大，哪怕就此离家越来越远，他们也会想尽办法来到你的身边。 小艾最后告诉我：“以后每个假期我都要回家。”语气充满了坚定，也充满了幸福。 当我们努力去踏遍千山万水的时候，千万别忘了回头看一看那个随时等你回家的人。 你还记得上一次回家探望他们是什么时候吗？ 你还记得上一次打电话给他们是什么时候吗？ 你还记得上一次真正和他们敞开心扉聊天是什么时候吗？…… 很喜欢这样一首小诗： 我们的世界很大，常忽略了他们。父母的世界很小，只装满了我们。 他们经常忘了，我们已经长大。就像我们经常忘了，他们已经渐渐白发。 诚然，外面的世界很精彩，但父母绝对不应该成为被我们遗忘的一部分。 因为一直以来，只有他们才会用最笨拙的方式默默地守护着我们。 无论你身处何种境遇，父母对孩子总是充满了牵挂。 并且也终于发现不知不觉那个等自己回家的人已经渐渐老去，自己亏欠他们太多太多。 我们总说来日方长，可人生哪来那么多后会有期。 世间最美好莫过于：我已长大，你还未老；我有能力报答，而你仍然健康。 有人问“逢年过节，为什么中国人总要不远万里回家？” 知乎上有个高赞回答，只有一句话，却触动人心： 因为那是我的“家”呀，别的地方只能叫做“住的地方”。 在网上看到过这样一个故事： 因为刚刚毕业，女孩一直没能找到工作，到了年底想要回乡，身上只剩下几百块钱。 路途遥远，她买不起机票，只好买最便宜的绿皮火车票，需要在硬座上待三十几个小时。 等她终于赶回家乡的城市，早已经是凌晨一点。 但是没想到，她刚一出站，就看到了在站台上翘首以盼的父亲。 深夜的车站人烟稀少，父亲缩着脖子，哈气搓手。看到她出现，小跑着过来。 接过行李的时候，父亲说：“外面混得不好就回来，爸养你。长了不敢说，养你到40岁，爸还是有这个能力的。” 听到父亲的话，她特别想哭，心里一直堵着难过，在到家的那一刻，突然释放了。 有人说，家是一个有温度的词，它不仅是我们身体休息的地方，更是我们心灵停靠的港湾。倦鸟归林、鱼翔浅底、落叶归根，这都是对家的渴望，也是生命在追寻着的一种归宿。 你终会发现，你心中最美的风景，不是霓虹闪烁，也不是高楼大厦，而是那个有父母等你回去，无论贫穷或富有的家。","link":"/夜读20191005/"},{"title":"记人恩，忘人过","text":"怀包容之心，还己一份轻松！活着不易，人人都有难处，做人，应常怀慈悲心，体谅他人的难处。人无完人，人人都有不足，常怀包容心，容纳万物，少计较，少对比，放过自己，不苛责他人，多去欣赏放大他人的优点，忽略他人的不足。 俗话说，烦恼天天有，不捡自然无，心宽一分云消雾散，让人一步晴空万里。 有一种心安，叫念人恩，有一种轻松，叫忘人过，帮过我们的，铭记于心，心宽，不念人过忘人错，不忘人恩，知恩图报，不记人过，心胸开阔，不思人非，不计人怨，踏实生活！ 心宽一尺，少记人过。 古人云：“一斗米养个恩人，一石米养个仇人。” 在生活中，总有这么一类人存在，你对他十次好，一次不顺心， 他就会抹杀所有，只记得你的过错，有些人习惯了索取，便忘记了付出、感恩。 在这个世界上并不是人人都懂“良心”两个字，纵然你有千般好，只要有一个不好，就推翻了你所有的付出；哪怕你为他倾尽所有，掏心掏肺，一个过错，就会揪着不放。 这类人，你帮他一百次却从不记恩，但半次不帮就记恨在心，永不忘怀。 人都是相互的，你怎么待人，别人也会以同样的方式待你，你待别人刻薄，别人就会远离你，你待他人真诚，别人就会珍惜你。 做人，靠心，不靠嘴，用真心待人，才能换得知己，用嘴巴待人，难以换得信任。 尺有所短，寸有所长，别拿自己的标准衡量人，别用自己的眼光审视人，人人都有不足，谁都不完美，挑人过错时，嘲笑他人的缺点时，先反省一下自身。 人活着，谁都不完美，都有难言的苦。别总是挑剔别人，不去反省自己的错误。 做人，理应用放大镜看别人的优点，用显微镜看自己的缺点，因为事事都不完美，别用自己的认知去评论一件事。 人人都有不足，别用自己的心胸去度人，用自己的心眼去要求他人，理应得饶人处且饶人，放过了别人，也等于放过了自己，怀包容之心，心宽一尺，还己一份轻松！ 常记人恩，知恩图报。 常言道：“别人帮你是情分，不帮你是本分。” 做人应有良心，常怀一颗感恩之心，不要因为别人一次拒绝你，就放在心上，揪着不放，人人都有为难之处，做人应换位思考，更不要把别人曾经对你的好抛却脑后。 不要因为一点小事，就否定别人之前对你的知遇之恩，就忘记别人对你所有的好。 在生活中，理应感恩每一次遇见、相逢、重逢。感恩每一个出现在我们生命里的人，因为他们都是我们生命中的贵人！ 感恩生我养我的爸妈，把我们带到人世间，给予我们生命；为我们扛起重担，教会我们做人的道理； 感恩老师，是他们无私的奉献和付出，一路启蒙、引导着我们。授予我们知识，助我们圆梦。念师恩，一生无悔！ 感恩朋友，当我们陷入低谷时，用真挚的友谊给予鼓励与安慰。当我们遇到麻烦时，及时伸出援助之手。当我们走投无路时，愿意倾囊相助。 君子重情不忘恩，小人重财记人过，懂感恩的，贵人助，记人过的，仇怨多。 古人云，滴水之恩，当涌泉相报，忘人过，记人恩，你的格局才会越来越大，人生之路才会越走越宽。 人活一世，如露水一朝，今生为人，好好踏踏实实做人。少记人过，常记人恩。 为人要诚恳，说话要中肯，做事要讲究诚信，说话算话；交人，要懂感恩，以心换心，将心比心。学会感恩，才会知足；学会感恩，才会保持恬淡自然的心态；学会感恩，才能看清自己，路才会更宽！","link":"/夜读20191007/"},{"title":"人，绝不能让心情生病","text":"能笑，就别选择哭！散文家林清玄的书法很好。 有一天，他的朋友向他讨要一副字，考虑再三，他写下了四个字：常想一二。 朋友问，这是什么意思？ 林清玄说了这样一段话：“人生不如意事十常八九，我们生命里不如意的事占了绝大部分，因此，活着本身是痛苦的。但扣除八、九成的不如意，至少还有一、二成是如意的、快乐的、欣慰的事。我们如果要过快乐的人生，就要常想那一、二成好事，这样就会感到庆幸、懂得珍惜，就不至于被八九成的不如意所打倒了。” 的确，生活里的大部分事，总是难熬痛苦的。 上学时，要日复一日地沉浸在学业里，每日都要为成绩提心吊胆。 工作后，既要承担沉重的经济压力，提起精神面对职场上的纷纷扰扰，又要照顾好一家老小，不管多累时间却好像总是不够用。 生活不如意之事太多了，哪怕艰难地挺过所有苦难，也不一定能有大欢喜降临。 可若是整日沉浸在对痛苦的厌恶、对压力的反感中，生活就会是灰蒙蒙的一片。 不如多想想那一二如意之事，哪怕快乐少有，也要记得快乐是什么样的味道，用这样的方式去生活，才会有阳光出现。 否则，心情生了病，生活也不会见好。 读过这样一则小故事。 有兄弟二人，大约四五岁。 因为卧室里的窗户总是密闭着，他们觉得室内太过暗沉，看到外面的阳光，很是羡慕，就想了一个主意：把阳光扫进来。 于是，他们拿着笤帚和畚箕去阳台扫阳光，但当他们把畚箕拿到屋里的时候，发现阳光没了。 他们尝试了很多次，还是没有阳光，开始着急。 这时妈妈看到了他俩奇怪的动作，问：“你们在做什么呢？” 两兄弟答道：“房间太暗了，我们想扫点儿阳光进来。” 妈妈笑了：“只要把窗户打开，阳光自然会进来，何必去扫呢？” 阳光就像我们的好心情，很多人知道它能驱散黑暗，带来温暖，能让日子欢快起来，很想努力拥有，却总是得不到。 但其实，当你真正放松下来，把封闭的心门打开，就会发现原来快乐并不难，阳光般的好心情自然而然就来了。 很多时候，我们总是把自己逼得太紧，什么都想要，什么都得不到，还把自己弄得一身狼藉。 适时放松一些，心情才不会那么容易就生病。 去看看云卷云舒，去赏赏春花秋叶，日子很美，只是我们习惯于沉浸在各种功名利禄里，忽略了心情的重要性。 人生短短几十年，总要活得开心些。 有个老太太喜欢买苹果，有次她买了一筐苹果，就找烂的吃掉，好的留到明天再吃，明天再找个烂的吃，好的再留着。 她不断地吃烂苹果，最后她吃掉了一筐烂苹果。 你看，其实生活就像那筐苹果，有烂的、也有好的，全看你先吃哪个。 先吃坏苹果，一天都会是坏心情，好苹果也会在你不经意间腐烂掉。 但先吃好苹果，至少当下的心情是欢快的。 我们无法把握明天，别把快乐都留在遥远的未来，因为生命无常，世事难料，谁也无法保证未来的你终会平安喜乐。 记住，不论昨天曾发生过什么事，也不论明天有什么即将来临，你永远“置身现在”。 一旦现在的心情生病了，就很难痊愈，未来的心情也会跟着受影响。 人只有活好每一个当下，用最好的心态去面对，人生之路才不会伴随太多悲叹，明天的快乐才会按时到达。 能笑，就别选择哭，能开开心心，就别抑郁低沉。想开了，一切就通畅了。 人，绝不能让心情生病。","link":"/夜读20191008/"},{"title":"活在当下，给自己找到一个恰到好处的位置","text":"有一部电影叫《遗愿清单》，讲了一个身价千万的富人和普通的汽车维修工同时患上了癌症，住进了一家医院，他们俩在病床上等待着即将来临的死亡，临终前回忆自己的一生真的过得快乐吗？ 富人一辈子为事业打拼，离过几次婚，不缺女人，尽管有钱但也没有真正的朋友和亲人，所以感到内心空虚，穷人一辈子抚养三个孩子，为了孩子放弃了很多自己喜欢的东西，省吃俭用把自己的一生奉献给了家庭，而自己还有很多遗憾。他们两个身份地位截然不同，但是在死亡面前却是平等的。 于是二人决定在人生最后的6个月里列下遗愿清单，为自己活一次，去做这一辈子觉得遗憾的事。 他们去高空跳伞，去飙车，去万里长城，去埃及金字塔，去埃塞俄比亚看野生动物，去喜马拉雅山目睹神迹，去出于善意帮助陌生人，去亲吻世界上最美的女孩，一段看世界的游历过后他们把最后的时光留给了家人。 他们收获了整个世界，最重要的事在人生最后的阶段，拥有了一段真挚无比的友情。 去世后他们二人的骨灰装在了最爱的咖啡罐头里，埋在了喜马拉雅山上。 电影带有浪漫的戏剧色彩，但也给我们的生活带来一些思考，人的生命有限，要在有限的生命里尽可能的去充实自己，去做自己喜欢的事，我们没有办法决定人生的长短，但至少可以决定人生厚度。 无论贫穷还是富贵，走到人生边上的时候，才发现人生被太多物质的外在的事物捆绑，而真正让自己快乐的是为自己活一次，我们甚至不知道明天和死亡哪一个先来，活在当下，做自己想做的事，去经历这段人生后所收获的爱情、友情、亲情。 我时常会想到人生，想到死亡。 在苍茫的宇宙里，如果有一双眼睛要怎样才能找到我，比一粒尘埃还要细微，即便是珠穆朗玛峰乃至整个地球，在银河系在星系团中也是沧海一粟。人类的微不足道常常让我产生一种虚无感，感觉活着做的一切都没有意义。 放大了尺度来看，生活即使虚无的，每个人都在命运的摆布下无力的生活着。恰恰因为如此，我们就应该活在当下，因为我们只存在于当下，人生是由无数个当下组成的，人应当在短暂的生命力找到自己恰到好处的位置。 我喜欢的作家张晓风在她新书《回首风烟》里阐述了她对自然的存在，生命的存在、时间的存在的哲学思辨，她写道：树在，山在，大地在，岁月在，我在。你还想要怎样更好的世界。她在书中用暖心的笔墨描绘她一生中的见闻和感悟，用人生大半辈子的经历告诫我们处事的智慧和乐观的生活态度。热爱当下的生活，享受当下的人生。 宇宙是浩瀚的，人生是虚无的。那我们生活的意义就在于，在当下有花草树木，有山水江河，有时间流淌，有爱人，有自己，尽管随着时间流转这些将会消逝，但至少当下这些是难得可贵的，是美好的。 把握住当下，活在现在，找准自己的位置，去行动，去感受自然，去珍惜身边可贵的人们，生命才会变得更加充实，自在。 有个故事这样讲道：有个小和尚，每天早上负责清扫寺院里的落叶。 清晨起床扫落叶实在是一件苦差事，尤其在秋冬之际，每一次起风时，树叶总随风飞舞。每天早上都需要花费许多时间才能清扫完树叶，这让小和尚头痛不已。他一直想要找个好办法让自己轻松些。 后来有个和尚跟他说：“你在明天打扫之前先用力摇树，把落叶统统摇下来，后天就可以不用扫落叶了。”小和尚觉得这是个好办法，于是隔天他起了个大早，使劲地猛摇树，这样他就可以把今天跟明天的落叶一次扫干净了。一整天小和尚都非常开心。 第二天，小和尚到院子里一看，他不禁傻眼了。院子里如往日一样满地落叶。 老和尚走了过来，对小和尚说：“傻孩子，无论你今天怎么用力，明天的落叶还是会飘下来。” 小和尚终于明白了，世上有很多事是无法提前的，不管人们怎么为未来担忧，也无法避免未来的可能性，惟有认真地活在当下，做好今天的每一件事，未来的交给未来的自己，才是最真实的人生态度。 克里希拉姆提说过：“所谓活在当下，就是在刹那间领会其中的美与喜悦，而不眷恋它所带来的快感。” 就像我们去看绘画展览，很多人路过一个景点就赶紧拿出手机拍照，希望留作纪念，想着能够给未来的自己看，而却忽视了这幅作品在你面前的那一刻给你带来的震撼和思考。 世界上有很多美转瞬即逝，有很多人匆匆路过就再也遇不见，所以我们要找准自己的位置，不要多虑未知之事，不要去奢望不能之事。做好当下的事，不要去等，去尽可能的去做想做之事。 因为当这个世界把自己呈现在我们面前的那一刻，我们可以喊出：我在！","link":"/美文20191006-01/"},{"title":"向美好的方向走，总有一天会遇见美好","text":"向着秋季的深处走去，夜晚的风凉快了许多。城市依旧车来人往的忙碌，很久没有抬头看月亮，低头走路久了，竟然忘记了许多美好的事物。 路上的车流排成一道风景，车灯点亮城市的夜空，在城市里即便是独处，身体也是不寂寞的，而让我们感觉孤独的是自己的内心。循着生命之路，走下去，也许这个秋天只是一段时光。 好多人总说“余生还长，无需慌张”，不尽然，一生真的不长，就在日月的交替里，我们不知不觉就从年少走到老去。弹指一挥间，往事皆如烟。 只有认真的感受此刻自己的生活，才不辜负时间的好。 年少不识愁滋味，为赋新诗强说愁。而今年华渐老，几多忧愁却难于开口。也只能安慰自己说，越来越成熟。其实所谓的成熟是我们不得不去深沉地对待生活。如果能有命运的厚爱，我们还是乐于一直做少年时那种无忧无虑的纯真。 在生活的行板上，遇见风和日丽，遭遇惊涛骇浪，不能停止的行程里，就连笑容也逐渐坚硬起来。每一位老者的表情都是肃穆而和蔼的，因为他们看过了人间的繁华和凄凉，懂得了敬畏和包容。 于是，在老去时又回归了孩童的童真，放下了一切身心的包袱。生命是一场轮回，从出生时的无知无识而纯粹，到老去时的看透和放下而活得纯粹。生命是神秘的，没有两个相同命运的人，它时时刻刻发生着变化，一步一步走下去，错过的风景再也回不到过去，所以心怀敬畏，珍惜当下。 时光里的美好，无处不在。路边开着的小野花，手中翻阅的书香，天上的月亮，河流在唱歌，小动物们那么可爱，晚风拂来清爽宜人，这一切的美好，都是对生命最厚实的赠予。你若不善待美好，那么美好将离你而去。 人在最努力的时候最好运，心存敬畏，在生命的历程中，认真坚持，才能成就更好的自己。当时对于写作的坚持源于作家林清玄的一番话，那天坐在一辆出租车上，收音机里的他很诚恳地说：“自己每天坚持写三千字，对他来说，已经是一种习惯了。”于是我尝试着每天坚持写一千字，日积月累在我写作的时候忽然发现很多时候写作不再枯涩，而是一种习惯。只要足够用力，生命的长度就会增加。 生活不是一床温软的被子，永远温暖踏实。它也有带给我们伤痛的时候，我们用心爱过的人，都成了彼此的亲人，彼此成了彼此的肌肉，骨头，血液，在分别的时候，痛彻心扉。太多我们不能掌控的事情在发生，无能为力中，只有心痛难忍。 时光是一个万花筒，转呀转就画出一幅美丽的画面，而生活的真相里，是残酷的现实。对待时光里发生的所有，始终保持热情。多向美好的方向走，总有一天我们会遇见美好。 秋夜的风吹来，每一盏灯火下都有自己的故事。我们不能替代别人的生活，别人也不能和自己感同身受。唯有在真实的生活里，认真地去对待，用最真的心去对待身边的人和这个世界。 始终保持敬畏之心，对时光，对美，对痛楚，永远去爱。","link":"/美文20191007-01/"}],"tags":[{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"夜读","slug":"夜读","link":"/tags/夜读/"},{"name":"美文","slug":"美文","link":"/tags/美文/"},{"name":"励志","slug":"励志","link":"/tags/励志/"}],"categories":[{"name":"面试","slug":"面试","link":"/categories/面试/"},{"name":"夜读","slug":"夜读","link":"/categories/夜读/"},{"name":"JavaScript","slug":"面试/JavaScript","link":"/categories/面试/JavaScript/"},{"name":"美文","slug":"夜读/美文","link":"/categories/夜读/美文/"},{"name":"美文","slug":"美文","link":"/categories/美文/"}]}